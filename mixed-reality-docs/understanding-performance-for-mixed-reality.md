---
title: Comprendre les performances de la réalité mixte
description: Rubriques avancées et détails sur l’optimisation des performances pour les applications Windows Mixed Reality
author: Troy-Ferrell
ms.author: trferrel
ms.date: 3/26/2019
ms.topic: article
keywords: Windows Mixed Reality, la réalité mixte, la réalité virtuelle, VR, MR, performances, optimisation, UC, GPU
ms.openlocfilehash: 7d8a0c95d59ec7e42e11bc1e1b6b40c702e01529
ms.sourcegitcommit: 6bc6757b9b273a63f260f1716c944603dfa51151
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 11/01/2019
ms.locfileid: "73438237"
---
# <a name="understanding-performance-for-mixed-reality"></a><span data-ttu-id="65ce2-104">Comprendre les performances de la réalité mixte</span><span class="sxs-lookup"><span data-stu-id="65ce2-104">Understanding performance for mixed reality</span></span>

<span data-ttu-id="65ce2-105">Cet article est une introduction à la compréhension de l’importance des performances de votre application de réalité mixte.</span><span class="sxs-lookup"><span data-stu-id="65ce2-105">This article is an introduction to understanding the significance of performance for your Mixed Reality app.</span></span>  <span data-ttu-id="65ce2-106">L’expérience utilisateur peut être très détériorée si votre application n’est pas exécutée à la fréquence d’images optimale.</span><span class="sxs-lookup"><span data-stu-id="65ce2-106">User experience can be greatly degraded if your application does not run at optimal frame rate.</span></span> <span data-ttu-id="65ce2-107">Les hologrammes apparaissent instables et le suivi des têtes de l’environnement n’est pas exact, ce qui entraîne une mauvaise expérience de l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="65ce2-107">Holograms will appear unstable and head tracking of the environment will be inaccurate, leading to an poor experience for the user.</span></span> <span data-ttu-id="65ce2-108">Les performances doivent être considérées comme une fonctionnalité de première classe pour le développement de la réalité mixte et non pour une tâche polonaise.</span><span class="sxs-lookup"><span data-stu-id="65ce2-108">Performance must be considered a first class feature for mixed reality development and not a polish task.</span></span>

<span data-ttu-id="65ce2-109">Les valeurs de fréquence d’images performante pour chaque plateforme cible sont répertoriées ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="65ce2-109">The performant framerate values for each target platform are listed below.</span></span>

| <span data-ttu-id="65ce2-110">Plateforme</span><span class="sxs-lookup"><span data-stu-id="65ce2-110">Platform</span></span> | <span data-ttu-id="65ce2-111">Fréquence d’images cible</span><span class="sxs-lookup"><span data-stu-id="65ce2-111">Target Frame Rate</span></span> |
|----------|-------------------|
| [<span data-ttu-id="65ce2-112">HoloLens</span><span class="sxs-lookup"><span data-stu-id="65ce2-112">HoloLens</span></span>](hololens-hardware-details.md) | <span data-ttu-id="65ce2-113">60 FPS</span><span class="sxs-lookup"><span data-stu-id="65ce2-113">60 FPS</span></span> |
| [<span data-ttu-id="65ce2-114">Windows Mixed Reality ultra PC</span><span class="sxs-lookup"><span data-stu-id="65ce2-114">Windows Mixed Reality Ultra PCs</span></span>](immersive-headset-hardware-details.md) | <span data-ttu-id="65ce2-115">90 FPS</span><span class="sxs-lookup"><span data-stu-id="65ce2-115">90 FPS</span></span> |
| [<span data-ttu-id="65ce2-116">PC Windows Mixed Reality</span><span class="sxs-lookup"><span data-stu-id="65ce2-116">Windows Mixed Reality PCs</span></span>](immersive-headset-hardware-details.md) | <span data-ttu-id="65ce2-117">60 FPS</span><span class="sxs-lookup"><span data-stu-id="65ce2-117">60 FPS</span></span> |

<span data-ttu-id="65ce2-118">Le cadre ci-dessous décrit les meilleures pratiques pour atteindre les fréquences d’images cibles.</span><span class="sxs-lookup"><span data-stu-id="65ce2-118">The framework below outlines best practices for hitting target frame rates.</span></span> <span data-ttu-id="65ce2-119">Si vous développez dans Unity, lisez les [recommandations relatives aux performances de l’article Unity](performance-recommendations-for-unity.md) pour obtenir des conseils sur la mesure et l’amélioration de la fréquence d’images dans l’environnement Unity.</span><span class="sxs-lookup"><span data-stu-id="65ce2-119">If developing in Unity, consider reading the [performance recommendations for Unity article](performance-recommendations-for-unity.md) for tips on measuring and improving framerate in the Unity environment.</span></span>

## <a name="understanding-performance-bottlenecks"></a><span data-ttu-id="65ce2-120">Comprendre les goulots d’étranglement des performances</span><span class="sxs-lookup"><span data-stu-id="65ce2-120">Understanding performance bottlenecks</span></span>

<span data-ttu-id="65ce2-121">Si votre application comporte une cadence de trames, la première étape consiste à analyser et à comprendre où votre application est gourmande en calculs.</span><span class="sxs-lookup"><span data-stu-id="65ce2-121">If your app has an underperforming framerate, the first step is to analyze and understand where your application is computationally intensive.</span></span> <span data-ttu-id="65ce2-122">Deux processeurs principaux sont responsables du travail de rendu de votre scène : l’UC et le GPU.</span><span class="sxs-lookup"><span data-stu-id="65ce2-122">There are two primary processors responsible for the work to render your scene: the CPU and the GPU.</span></span> <span data-ttu-id="65ce2-123">Chacun de ces éléments gère différents aspects de votre application de réalité mixte.</span><span class="sxs-lookup"><span data-stu-id="65ce2-123">Each of these handle different aspects of your Mixed Reality app.</span></span> <span data-ttu-id="65ce2-124">Il existe trois emplacements clés où les goulots d’étranglement peuvent se produire :</span><span class="sxs-lookup"><span data-stu-id="65ce2-124">There are three key places where bottlenecks may occur:</span></span> 

1. <span data-ttu-id="65ce2-125">**Thread d’application-UC** : ce thread est responsable de la logique de votre application.</span><span class="sxs-lookup"><span data-stu-id="65ce2-125">**App Thread - CPU** - This thread is responsible for your app logic.</span></span> <span data-ttu-id="65ce2-126">Cela comprend le traitement des entrées, des animations, de la physique et d’autres logiques d’application.</span><span class="sxs-lookup"><span data-stu-id="65ce2-126">This includes processing input, animations, physics, and other app logic.</span></span>
2. <span data-ttu-id="65ce2-127">**Rendu thread-CPU au GPU** : ce thread est chargé d’envoyer vos appels de dessin au GPU.</span><span class="sxs-lookup"><span data-stu-id="65ce2-127">**Render Thread - CPU to GPU** - This thread is responsible for submitting your draw calls to the GPU.</span></span> <span data-ttu-id="65ce2-128">Lorsque votre application souhaite afficher un objet tel qu’un cube ou un modèle, ce thread envoie une demande au GPU pour effectuer ces opérations.</span><span class="sxs-lookup"><span data-stu-id="65ce2-128">When your app wants to render an object such as a cube or model, this thread sends a request to the GPU to perform these operations.</span></span>
3. <span data-ttu-id="65ce2-129">**GPU** : ce processeur gère le plus souvent le pipeline graphique de votre application pour transformer des données 3D (modèles, textures, etc.) en pixels.</span><span class="sxs-lookup"><span data-stu-id="65ce2-129">**GPU** - This processor most commonly handles the graphics pipeline of your application to transform 3D data (models, textures, etc.) into pixels.</span></span> <span data-ttu-id="65ce2-130">Il produit finalement une image 2D à envoyer à l’écran de votre appareil.</span><span class="sxs-lookup"><span data-stu-id="65ce2-130">It ultimately produces a 2D image to submit to your device's screen.</span></span>

![Durée de vie d’un frame](images/lifetime-of-a-frame.png)

<span data-ttu-id="65ce2-132">En règle générale, les applications HoloLens sont liées au GPU, mais pas toujours.</span><span class="sxs-lookup"><span data-stu-id="65ce2-132">Generally, HoloLens applications will be GPU bound, but not always.</span></span> <span data-ttu-id="65ce2-133">Utilisez les outils et les techniques ci-dessous pour comprendre où votre application particulière est engorgée.</span><span class="sxs-lookup"><span data-stu-id="65ce2-133">Use the tools and techniques below to understand where your particular app is bottlenecked.</span></span>

## <a name="how-to-analyze-your-application"></a><span data-ttu-id="65ce2-134">Comment analyser votre application</span><span class="sxs-lookup"><span data-stu-id="65ce2-134">How to analyze your application</span></span>

<span data-ttu-id="65ce2-135">De nombreux outils vous permettent de comprendre le profil de performances de votre application de réalité mixte.</span><span class="sxs-lookup"><span data-stu-id="65ce2-135">There are many tools that allow you to understand the performance profile of your mixed reality application.</span></span> <span data-ttu-id="65ce2-136">Ils vous permettront de déterminer où et pourquoi les goulots d’étranglement vous sont utiles. vous pouvez donc les résoudre.</span><span class="sxs-lookup"><span data-stu-id="65ce2-136">These will enable you to find where and why you have bottlenecks, so you can address them.</span></span>

<span data-ttu-id="65ce2-137">Voici quelques outils courants pour obtenir des informations de profilage détaillés pour votre application :</span><span class="sxs-lookup"><span data-stu-id="65ce2-137">Below are some common tools to gain deep profiling information for your application:</span></span>
- [<span data-ttu-id="65ce2-138">Analyseurs de performances graphiques Intel</span><span class="sxs-lookup"><span data-stu-id="65ce2-138">Intel Graphics Performance Analyzers</span></span>](https://software.intel.com/gpa)
- [<span data-ttu-id="65ce2-139">Débogueurs graphiques Visual Studio</span><span class="sxs-lookup"><span data-stu-id="65ce2-139">Visual Studio Graphics Debuggers</span></span>](https://docs.microsoft.com/visualstudio/debugger/graphics/visual-studio-graphics-diagnostics?view=vs-2017)
- [<span data-ttu-id="65ce2-140">Profileur Unity</span><span class="sxs-lookup"><span data-stu-id="65ce2-140">Unity Profiler</span></span>](https://docs.unity3d.com/Manual/Profiler.html)
- [<span data-ttu-id="65ce2-141">Débogueur de frames Unity</span><span class="sxs-lookup"><span data-stu-id="65ce2-141">Unity Frame Debugger</span></span>](https://docs.unity3d.com/Manual/FrameDebugger.html)

### <a name="how-to-profile-in-any-environment"></a><span data-ttu-id="65ce2-142">Comment Profiler dans n’importe quel environnement</span><span class="sxs-lookup"><span data-stu-id="65ce2-142">How to profile in any environment</span></span>

<span data-ttu-id="65ce2-143">Une façon de déterminer si vous êtes lié au GPU ou à l’UC dans votre application est de réduire la résolution de la sortie de la cible de rendu.</span><span class="sxs-lookup"><span data-stu-id="65ce2-143">One way to determine if you are GPU bound or CPU bound in your application is to decrease the resolution of the render target output.</span></span> <span data-ttu-id="65ce2-144">En réduisant le nombre de pixels à calculer, vous réduisez la charge du GPU.</span><span class="sxs-lookup"><span data-stu-id="65ce2-144">By reducing the number of pixels to calculate, this will reduce your GPU load.</span></span> <span data-ttu-id="65ce2-145">L’appareil est rendu sur une texture plus petite, puis sur un échantillon pour afficher votre image finale.</span><span class="sxs-lookup"><span data-stu-id="65ce2-145">The device will render to a smaller texture, then up-sample to display your final image.</span></span>

<span data-ttu-id="65ce2-146">Après une réduction de la résolution de rendu, si :</span><span class="sxs-lookup"><span data-stu-id="65ce2-146">After decreasing rendering resolution, if:</span></span>
1) <span data-ttu-id="65ce2-147">L’application de fréquence d’images **augmente**, vous êtes probablement **lié au GPU**</span><span class="sxs-lookup"><span data-stu-id="65ce2-147">Application framerate **increases**, then you are likely **GPU Bound**</span></span>
1) <span data-ttu-id="65ce2-148">Fréquence d’application **inchangée**, vous êtes probablement lié à l' **UC**</span><span class="sxs-lookup"><span data-stu-id="65ce2-148">Application framerate **unchanged**, then you are likely **CPU Bound**</span></span>

>[!NOTE]
><span data-ttu-id="65ce2-149">Unity offre la possibilité de modifier facilement la résolution de la cible de rendu de votre application au moment de l’exécution via la propriété *[XRSettings. renderViewportScale](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)* .</span><span class="sxs-lookup"><span data-stu-id="65ce2-149">Unity provides the ability to easily modify the render target resolution of your application at runtime through the *[XRSettings.renderViewportScale](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)* property.</span></span> <span data-ttu-id="65ce2-150">La résolution de l’image finale présentée sur l’appareil est fixe.</span><span class="sxs-lookup"><span data-stu-id="65ce2-150">The final image presented on device has a fixed resolution.</span></span> <span data-ttu-id="65ce2-151">La plateforme échantillonne la sortie de résolution inférieure pour générer une image de résolution supérieure pour le rendu sur les affichages.</span><span class="sxs-lookup"><span data-stu-id="65ce2-151">The platform will sample the lower resolution output to build a higher resolution image for rendering on displays.</span></span> 
>
>```CS
>UnityEngine.XR.XRSettings.renderScale = 0.7f;
>```

## <a name="how-to-improve-your-application"></a><span data-ttu-id="65ce2-152">Comment améliorer votre application</span><span class="sxs-lookup"><span data-stu-id="65ce2-152">How to improve your application</span></span>

### <a name="cpu-performance-recommendations"></a><span data-ttu-id="65ce2-153">Recommandations relatives aux performances de l’UC</span><span class="sxs-lookup"><span data-stu-id="65ce2-153">CPU performance recommendations</span></span>

<span data-ttu-id="65ce2-154">En règle générale, la plupart des travaux dans une application de réalité mixte sur l’UC impliquent la « simulation » de la scène et le traitement de votre logique d’application.</span><span class="sxs-lookup"><span data-stu-id="65ce2-154">Generally, most work in a mixed reality application on the CPU involves performing the "simulation" of the scene and processing your application logic.</span></span> <span data-ttu-id="65ce2-155">Les zones suivantes sont généralement destinées à l’optimisation :</span><span class="sxs-lookup"><span data-stu-id="65ce2-155">The following areas are usually targeted for optimization:</span></span>

- <span data-ttu-id="65ce2-156">Animations</span><span class="sxs-lookup"><span data-stu-id="65ce2-156">Animations</span></span>
- <span data-ttu-id="65ce2-157">Physique</span><span class="sxs-lookup"><span data-stu-id="65ce2-157">Physics</span></span>
- <span data-ttu-id="65ce2-158">Allocations de mémoire</span><span class="sxs-lookup"><span data-stu-id="65ce2-158">Memory allocations</span></span>
- <span data-ttu-id="65ce2-159">Algorithmes complexes (c.-à-d.</span><span class="sxs-lookup"><span data-stu-id="65ce2-159">Complex algorithms (i.e</span></span> <span data-ttu-id="65ce2-160">cinématique inverse, recherche de chemin d’accès)</span><span class="sxs-lookup"><span data-stu-id="65ce2-160">inverse kinematics, path-finding)</span></span>

### <a name="gpu-performance-recommendations"></a><span data-ttu-id="65ce2-161">Recommandations relatives aux performances GPU</span><span class="sxs-lookup"><span data-stu-id="65ce2-161">GPU performance recommendations</span></span>

#### <a name="understanding-bandwidth-vs-fill-rate"></a><span data-ttu-id="65ce2-162">Fonctionnement de la bande passante et du taux de remplissage</span><span class="sxs-lookup"><span data-stu-id="65ce2-162">Understanding bandwidth vs. fill rate</span></span>
<span data-ttu-id="65ce2-163">Lors du rendu d’une trame sur le GPU, une application est généralement liée par la bande passante de mémoire ou le taux de remplissage.</span><span class="sxs-lookup"><span data-stu-id="65ce2-163">When rendering a frame on the GPU, an application is generally either bound by memory bandwidth or fill rate.</span></span>

- <span data-ttu-id="65ce2-164">La **bande passante** de la mémoire est le taux de lectures et d’écritures que le GPU peut exécuter à partir de la mémoire</span><span class="sxs-lookup"><span data-stu-id="65ce2-164">**Memory bandwidth** is the rate of reads and writes the GPU can perform from memory</span></span>
    - <span data-ttu-id="65ce2-165">Pour identifier les limitations de bande passante, réduisez la qualité de la texture et vérifiez si la fréquence d’images a été améliorée.</span><span class="sxs-lookup"><span data-stu-id="65ce2-165">To identify bandwidth limitations, reduce texture quality and check if the framerate has improved.</span></span>
    - <span data-ttu-id="65ce2-166">Dans Unity, cette opération peut être effectuée en modifiant la qualité de la **texture** dans **modifier** > **paramètres du projet** > paramètres de **[qualité](https://docs.unity3d.com/Manual/class-QualitySettings.html)** .</span><span class="sxs-lookup"><span data-stu-id="65ce2-166">In Unity, this can be done by changing **Texture Quality** in **Edit** > **Project Settings** > **[Quality Settings](https://docs.unity3d.com/Manual/class-QualitySettings.html)**.</span></span>
- <span data-ttu-id="65ce2-167">Le **taux de remplissage** fait référence aux pixels qui peuvent être dessinés par seconde par le GPU.</span><span class="sxs-lookup"><span data-stu-id="65ce2-167">**Fill rate** refers to the pixels that can be drawn per second by the GPU.</span></span>
    - <span data-ttu-id="65ce2-168">Pour identifier les limitations du taux de remplissage, diminuez la résolution de l’affichage et vérifiez si les images sont améliorées.</span><span class="sxs-lookup"><span data-stu-id="65ce2-168">To identify fill rate limitations, decrease the display resolution and check if framerate improved.</span></span> 
    - <span data-ttu-id="65ce2-169">Dans Unity, cette opération peut être effectuée via la propriété *[XRSettings. renderViewportScale](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)*</span><span class="sxs-lookup"><span data-stu-id="65ce2-169">In Unity, this can be done via the  *[XRSettings.renderViewportScale](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)* property</span></span>

<span data-ttu-id="65ce2-170">La bande passante de la mémoire implique généralement des optimisations pour :</span><span class="sxs-lookup"><span data-stu-id="65ce2-170">Memory bandwidth generally involves optimizations to either:</span></span>
1) <span data-ttu-id="65ce2-171">Réduire les résolutions de texture</span><span class="sxs-lookup"><span data-stu-id="65ce2-171">Decrease texture resolutions</span></span>
2) <span data-ttu-id="65ce2-172">Utilisez moins de textures (normales, spéculaire, etc.)</span><span class="sxs-lookup"><span data-stu-id="65ce2-172">Utilize fewer textures (normals, specular, etc.)</span></span>

<span data-ttu-id="65ce2-173">Le taux de remplissage est axé sur la réduction du nombre d’opérations qui doivent être calculées pour un pixel rendu final.</span><span class="sxs-lookup"><span data-stu-id="65ce2-173">Fill rate is focused on reducing the number of operations that need to be computed for a final rendered pixel.</span></span> <span data-ttu-id="65ce2-174">Cela comprend la réduction des éléments suivants :</span><span class="sxs-lookup"><span data-stu-id="65ce2-174">This includes reducing:</span></span>
1) <span data-ttu-id="65ce2-175">Nombre d’objets à restituer/traiter</span><span class="sxs-lookup"><span data-stu-id="65ce2-175">Number of objects to render/process</span></span>
2) <span data-ttu-id="65ce2-176">Nombre d’opérations par nuanceur</span><span class="sxs-lookup"><span data-stu-id="65ce2-176">Number of operations per shader</span></span>
3) <span data-ttu-id="65ce2-177">Nombre d’étapes du GPU vers le résultat final (nuanceurs Geometry, effets de la postérieure au traitement, etc.)</span><span class="sxs-lookup"><span data-stu-id="65ce2-177">Number of GPU stages to final result (geometry shaders, post-processing effects, etc.)</span></span>
4) <span data-ttu-id="65ce2-178">Nombre de pixels à afficher (résolution d’affichage)</span><span class="sxs-lookup"><span data-stu-id="65ce2-178">Number of pixels to render (display resolution)</span></span>

#### <a name="reduce-polygon-count"></a><span data-ttu-id="65ce2-179">Réduire le nombre de polygones</span><span class="sxs-lookup"><span data-stu-id="65ce2-179">Reduce polygon count</span></span>
<span data-ttu-id="65ce2-180">Des nombres de polygones plus élevés entraînent davantage d’opérations pour le GPU. la réduction du nombre de polygones dans votre scène réduira le temps de rendu.</span><span class="sxs-lookup"><span data-stu-id="65ce2-180">Higher polygon counts result in more operations for the GPU; reducing the number of polygons in your scene will reduce the render time.</span></span> <span data-ttu-id="65ce2-181">D’autres facteurs sont impliqués dans l’ombrage de la géométrie qui peut être coûteuse, mais le nombre de polygones est la mesure la plus simple pour déterminer le coût de l’affichage d’une scène.</span><span class="sxs-lookup"><span data-stu-id="65ce2-181">There are other factors involved in shading the geometry that can be expensive, but polygon count is the simplest metric to determine how expensive a scene will be to render.</span></span>

#### <a name="limit-overdraw"></a><span data-ttu-id="65ce2-182">Limiter le surdessin</span><span class="sxs-lookup"><span data-stu-id="65ce2-182">Limit overdraw</span></span>

<span data-ttu-id="65ce2-183">Un surdessin élevé se produit lorsque plusieurs objets sont rendus mais non affichés à l’écran, car ils sont masqués par un objet occlusion.</span><span class="sxs-lookup"><span data-stu-id="65ce2-183">High overdraw occurs when multiple objects are rendered but not shown on screen as they are hidden by an occluding object.</span></span> <span data-ttu-id="65ce2-184">Imaginez que vous examinez un mur qui contient des objets en arrière-plan.</span><span class="sxs-lookup"><span data-stu-id="65ce2-184">Imagine looking at a wall that has objects behind it.</span></span> <span data-ttu-id="65ce2-185">Toute la géométrie est traitée pour le rendu, mais seul le mur opaque doit être rendu.</span><span class="sxs-lookup"><span data-stu-id="65ce2-185">All of the geometry would be processed for rendering, but only the opaque wall needs to be rendered.</span></span> <span data-ttu-id="65ce2-186">Cela entraîne des opérations inutiles.</span><span class="sxs-lookup"><span data-stu-id="65ce2-186">This results in unnecessary operations.</span></span>

#### <a name="shaders"></a><span data-ttu-id="65ce2-187">Nuanceurs</span><span class="sxs-lookup"><span data-stu-id="65ce2-187">Shaders</span></span>

<span data-ttu-id="65ce2-188">Les nuanceurs sont des petits programmes qui s’exécutent sur le GPU et effectuent deux étapes importantes en matière de rendu :</span><span class="sxs-lookup"><span data-stu-id="65ce2-188">Shaders are small programs that run on the GPU and perform two important steps in rendering:</span></span>
1) <span data-ttu-id="65ce2-189">Détermination des vertex à dessiner et de leur emplacement dans l’espace à l’écran (le nuanceur de sommets)</span><span class="sxs-lookup"><span data-stu-id="65ce2-189">Determining which vertices should be drawn and where they are in screen space (the Vertex shader)</span></span>
    - <span data-ttu-id="65ce2-190">Le nuanceur vertex est généralement exécuté par vertex pour chaque maille.</span><span class="sxs-lookup"><span data-stu-id="65ce2-190">The Vertex shader is generally executed per vertex for every mesh.</span></span>
2) <span data-ttu-id="65ce2-191">Détermination de la couleur de chaque pixel (nuanceur de pixels)</span><span class="sxs-lookup"><span data-stu-id="65ce2-191">Determining the color of each pixel (the Pixel shader)</span></span>
    - <span data-ttu-id="65ce2-192">Le nuanceur de pixels est exécuté par pixel rendu par la géométrie à la texture rendue.</span><span class="sxs-lookup"><span data-stu-id="65ce2-192">The Pixel shader is executed per pixel rendered by the geometry to the texture being rendered to.</span></span>

<span data-ttu-id="65ce2-193">En règle générale, les nuanceurs effectuent de nombreuses transformations et des calculs d’éclairage.</span><span class="sxs-lookup"><span data-stu-id="65ce2-193">Typically, shaders perform many transformations and lighting calculations.</span></span> <span data-ttu-id="65ce2-194">Bien que les modèles d’éclairage complexes, les ombres et les autres opérations puissent générer des résultats fantastiques, ils sont également fournis avec un prix.</span><span class="sxs-lookup"><span data-stu-id="65ce2-194">Although complex lighting models, shadows, and other operations can generate fantastic results, they also come with a price.</span></span> <span data-ttu-id="65ce2-195">La réduction du nombre d’opérations calculées dans les nuanceurs peut réduire considérablement le travail nécessaire pour le GPU par trame.</span><span class="sxs-lookup"><span data-stu-id="65ce2-195">Reducing the number of operations computed in shaders can greatly reduce the work needed for the GPU per frame.</span></span>

##### <a name="shader-coding-recommendations"></a><span data-ttu-id="65ce2-196">Recommandations en matière de codage de nuanceur</span><span class="sxs-lookup"><span data-stu-id="65ce2-196">Shader coding recommendations</span></span>

- <span data-ttu-id="65ce2-197">Utiliser le filtrage bilinéaire, dans la mesure du possible</span><span class="sxs-lookup"><span data-stu-id="65ce2-197">Use bilinear filtering, whenever possible</span></span>
- <span data-ttu-id="65ce2-198">Réorganiser les expressions pour utiliser des intrinsèques MAD afin d’effectuer une multiplication et un ajout en même temps</span><span class="sxs-lookup"><span data-stu-id="65ce2-198">Rearrange expressions to use MAD intrinsics in order to do a multiply and an add at the same time</span></span>
- <span data-ttu-id="65ce2-199">Précalculez autant que possible sur le processeur et transmettez-les en tant que constantes au matériel.</span><span class="sxs-lookup"><span data-stu-id="65ce2-199">Precalculate as much as possible on the CPU and pass as constants to the material</span></span>
- <span data-ttu-id="65ce2-200">**Privilégier les opérations de déplacement du nuanceur de pixels vers le nuanceur de sommets**</span><span class="sxs-lookup"><span data-stu-id="65ce2-200">**Favor moving operations from the pixel shader to the vertex shader**</span></span>
    - <span data-ttu-id="65ce2-201">En règle générale, le nombre de vertex est bien plus petit que le nombre de pixels (720p est de 921 600 pixels, 1080p est 2 073 600 pixels, etc.)</span><span class="sxs-lookup"><span data-stu-id="65ce2-201">Generally, the number of vertices is much smaller than the number of pixels (720p is 921,600 pixels, 1080p is 2,073,600 pixels, etc.)</span></span>

#### <a name="remove-gpu-stages"></a><span data-ttu-id="65ce2-202">Supprimer les étapes du GPU</span><span class="sxs-lookup"><span data-stu-id="65ce2-202">Remove GPU stages</span></span>
<span data-ttu-id="65ce2-203">Les effets postérieurs au traitement peuvent être très onéreux et augmenter le taux de remplissage de votre application.</span><span class="sxs-lookup"><span data-stu-id="65ce2-203">Post-processing effects can be very expensive and increase the fill rate of your application.</span></span> <span data-ttu-id="65ce2-204">Cela comprend les techniques d’anticrénelage telles que MSAA.</span><span class="sxs-lookup"><span data-stu-id="65ce2-204">This includes anti-aliasing techniques such as MSAA.</span></span> <span data-ttu-id="65ce2-205">Sur HoloLens, il est recommandé d’éviter ces techniques entièrement, ainsi que des étapes de nuanceur supplémentaires telles que Geometry, la coque et les nuanceurs de calcul.</span><span class="sxs-lookup"><span data-stu-id="65ce2-205">On HoloLens, it is recommended to avoid these techniques entirely, as well as additional shader stages such as geometry, hull, and compute shaders.</span></span>

## <a name="memory-recommendations"></a><span data-ttu-id="65ce2-206">Recommandations de mémoire</span><span class="sxs-lookup"><span data-stu-id="65ce2-206">Memory recommendations</span></span>
<span data-ttu-id="65ce2-207">Les opérations d’allocation et de désallocation de mémoire excessives peuvent entraîner des performances incohérentes, des frames figés et d’autres comportements nuisibles.</span><span class="sxs-lookup"><span data-stu-id="65ce2-207">Excessive memory allocation and deallocation operations can result in inconsistent performance, frozen frames, and other detrimental behavior.</span></span> <span data-ttu-id="65ce2-208">Il est particulièrement important de comprendre les considérations relatives à la mémoire lors du développement dans Unity, car la gestion de la mémoire est contrôlée par le garbage collector.</span><span class="sxs-lookup"><span data-stu-id="65ce2-208">It is especially important to understand memory considerations when developing in Unity, since memory management is controlled by the garbage collector.</span></span>

#### <a name="object-pooling"></a><span data-ttu-id="65ce2-209">Mise en pool d’objets</span><span class="sxs-lookup"><span data-stu-id="65ce2-209">Object pooling</span></span>

<span data-ttu-id="65ce2-210">Le mise en pool d’objets est une technique populaire pour réduire le coût des allocations et des désallocations continues d’objets.</span><span class="sxs-lookup"><span data-stu-id="65ce2-210">Object pooling is a popular technique to reduce the cost of continuous allocations and deallocations of objects.</span></span> <span data-ttu-id="65ce2-211">Pour ce faire, vous devez allouer un grand pool d’objets identiques et réutiliser les instances inactives de ce pool au lieu de générer et de détruire constamment des objets dans le temps.</span><span class="sxs-lookup"><span data-stu-id="65ce2-211">This is done by allocating a large pool of identical objects and re-using inactive, available instances from this pool instead of constantly spawning and destroying objects over time.</span></span> <span data-ttu-id="65ce2-212">Les pools d’objets sont idéaux pour les composants réutilisables qui ont une durée de vie variable pendant une application.</span><span class="sxs-lookup"><span data-stu-id="65ce2-212">Object pools are great for re-useable components that have variable lifetime during an app.</span></span>

## <a name="see-also"></a><span data-ttu-id="65ce2-213">Articles associés</span><span class="sxs-lookup"><span data-stu-id="65ce2-213">See also</span></span>
- [<span data-ttu-id="65ce2-214">Recommandations de performances pour Unity</span><span class="sxs-lookup"><span data-stu-id="65ce2-214">Performance recommendations for Unity</span></span>](performance-recommendations-for-unity.md)
- [<span data-ttu-id="65ce2-215">Paramètres recommandés pour Unity</span><span class="sxs-lookup"><span data-stu-id="65ce2-215">Recommended settings for Unity</span></span>](recommended-settings-for-unity.md)
