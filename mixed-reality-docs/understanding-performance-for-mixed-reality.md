---
title: Comprendre les performances de la réalité mixte
description: Rubriques avancées et détails sur l’optimisation des performances pour les applications Windows Mixed Reality
author: Troy-Ferrell
ms.author: trferrel
ms.date: 3/26/2019
ms.topic: article
keywords: Windows Mixed Reality, la réalité mixte, la réalité virtuelle, VR, MR, performances, optimisation, UC, GPU
ms.openlocfilehash: ce59f9023c21dc7c981a2bb97d9fbd0c57622dbf
ms.sourcegitcommit: 915d3cc63a5571ba22ac4608589f3eca8da1bc81
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/24/2019
ms.locfileid: "63548844"
---
# <a name="understanding-performance-for-mixed-reality"></a><span data-ttu-id="c0c10-104">Comprendre les performances de la réalité mixte</span><span class="sxs-lookup"><span data-stu-id="c0c10-104">Understanding performance for mixed reality</span></span>

<span data-ttu-id="c0c10-105">Cet article est une introduction à la rationalisation de l’importance des performances pour votre application de réalité mixte.</span><span class="sxs-lookup"><span data-stu-id="c0c10-105">This article is an introduction into rationalizing the significance of performance for your Mixed Reality app.</span></span>  <span data-ttu-id="c0c10-106">L’expérience utilisateur peut être très détériorée si votre application n’est pas exécutée à la fréquence d’images optimale.</span><span class="sxs-lookup"><span data-stu-id="c0c10-106">User experience can be greatly degraded if your application does not run at optimal frame rate.</span></span> <span data-ttu-id="c0c10-107">Les hologrammes apparaissent instables et le suivi des têtes de l’environnement est incorrect, conduisant à une expérience médiocre pour l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="c0c10-107">Holograms will appear unstable and head tracking of the environment will be inaccurate leading to an poor experience for the user.</span></span> <span data-ttu-id="c0c10-108">En effet, les performances doivent être considérées comme une fonctionnalité de première classe pour le développement de la réalité mixte et non une tâche de stabilisation, de fin de cycle.</span><span class="sxs-lookup"><span data-stu-id="c0c10-108">Indeed, performance must be considered as a first class feature for Mixed Reality development and not a stabilization, end of cycle task.</span></span>

<span data-ttu-id="c0c10-109">À des fins de révision, les valeurs de fréquence d’images performante pour chaque plateforme cible sont répertoriées ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="c0c10-109">For review, the performant framerate values for each target platform are listed below.</span></span>

| <span data-ttu-id="c0c10-110">Plateforme</span><span class="sxs-lookup"><span data-stu-id="c0c10-110">Platform</span></span> | <span data-ttu-id="c0c10-111">Fréquence d’images cible</span><span class="sxs-lookup"><span data-stu-id="c0c10-111">Target Frame Rate</span></span> |
|----------|-------------------|
| [<span data-ttu-id="c0c10-112">HoloLens</span><span class="sxs-lookup"><span data-stu-id="c0c10-112">HoloLens</span></span>](hololens-hardware-details.md) | <span data-ttu-id="c0c10-113">60 FPS</span><span class="sxs-lookup"><span data-stu-id="c0c10-113">60 FPS</span></span> |
| [<span data-ttu-id="c0c10-114">Windows Mixed Reality ultra PC</span><span class="sxs-lookup"><span data-stu-id="c0c10-114">Windows Mixed Reality Ultra PCs</span></span>](immersive-headset-hardware-details.md) | <span data-ttu-id="c0c10-115">90 FPS</span><span class="sxs-lookup"><span data-stu-id="c0c10-115">90 FPS</span></span> |
| [<span data-ttu-id="c0c10-116">PC Windows Mixed Reality</span><span class="sxs-lookup"><span data-stu-id="c0c10-116">Windows Mixed Reality PCs</span></span>](immersive-headset-hardware-details.md) | <span data-ttu-id="c0c10-117">60 FPS</span><span class="sxs-lookup"><span data-stu-id="c0c10-117">60 FPS</span></span> |

<span data-ttu-id="c0c10-118">Le cadre ci-dessous fournit un plan général pour les meilleures pratiques et des compréhensions pour atteindre les fréquences d’images cibles.</span><span class="sxs-lookup"><span data-stu-id="c0c10-118">The framework below gives a general outline for best practices and understandings towards hitting target frame rates.</span></span> <span data-ttu-id="c0c10-119">Pour approfondir vos connaissances, prenez connaissance [des recommandations relatives aux performances de l’article Unity](performance-recommendations-for-unity.md).</span><span class="sxs-lookup"><span data-stu-id="c0c10-119">To dive further into details, consider reading the [performance recommendations for Unity article](performance-recommendations-for-unity.md).</span></span> <span data-ttu-id="c0c10-120">En particulier, cet article décrit comment mesurer la fréquence d’images dans votre application Windows Mixed Reality Unity, ainsi que les étapes à suivre dans l’environnement Unity pour améliorer les performances.</span><span class="sxs-lookup"><span data-stu-id="c0c10-120">In particular, this related article will discuss how to measure framerate in your Unity Windows Mixed Reality app as well as steps to take in the Unity environment to improve performance.</span></span>

## <a name="understanding-performance-bottlenecks"></a><span data-ttu-id="c0c10-121">Comprendre les goulots d’étranglement des performances</span><span class="sxs-lookup"><span data-stu-id="c0c10-121">Understanding performance bottlenecks</span></span>

<span data-ttu-id="c0c10-122">Si votre application comporte une cadence de trames, la première étape consiste à analyser et à comprendre où votre application est gourmande en calculs.</span><span class="sxs-lookup"><span data-stu-id="c0c10-122">If your app has an underperforming framerate, the first step is to analyze and understand where your application is computationally intensive.</span></span> <span data-ttu-id="c0c10-123">Deux processeurs principaux sont responsables du travail de rendu de votre scène: l’UC et le GPU.</span><span class="sxs-lookup"><span data-stu-id="c0c10-123">There are two primary processors responsible for the work to render your scene: the CPU and the GPU.</span></span> <span data-ttu-id="c0c10-124">Chacun de ces deux composants gère différentes opérations et étapes de votre application de réalité mixte.</span><span class="sxs-lookup"><span data-stu-id="c0c10-124">Each of these two components handle different operations and stages of your Mixed Reality app.</span></span> <span data-ttu-id="c0c10-125">Il existe trois emplacements clés où les goulots d’étranglement peuvent se produire.</span><span class="sxs-lookup"><span data-stu-id="c0c10-125">There are three key places where bottlenecks may occur.</span></span> 

1. <span data-ttu-id="c0c10-126">**Thread d’application-UC** : ce thread est responsable de la logique de votre application.</span><span class="sxs-lookup"><span data-stu-id="c0c10-126">**App Thread - CPU** - This thread is responsible for your app logic.</span></span> <span data-ttu-id="c0c10-127">Cela comprend le traitement des entrées, des animations, de la physique et d’autres logiques/États de l’application.</span><span class="sxs-lookup"><span data-stu-id="c0c10-127">This includes processing input, animations, physics, and other app logic/state</span></span>
2. <span data-ttu-id="c0c10-128">**Rendu thread-CPU au GPU** : ce thread est chargé d’envoyer vos appels de dessin au GPU.</span><span class="sxs-lookup"><span data-stu-id="c0c10-128">**Render Thread - CPU to GPU** - This thread is responsible for submitting your draw calls to the GPU.</span></span> <span data-ttu-id="c0c10-129">Lorsque votre application souhaite effectuer le rendu d’un objet tel qu’un cube ou un modèle, ce thread envoie une requête au GPU, qui a une architecture optimisée pour le rendu, pour effectuer ces opérations.</span><span class="sxs-lookup"><span data-stu-id="c0c10-129">When your app wants to render an object such as a cube or model, this thread sends a request to the GPU, which has an architecture optimized for rendering, to perform these operations.</span></span>
3. <span data-ttu-id="c0c10-130">**GPU** - 
    Le plus souvent, ce processeur gère le pipeline graphique de votre application pour transformer des données 3D (modèles, textures, etc.) en pixels et produire une image 2D à envoyer à l’écran de votre appareil.</span><span class="sxs-lookup"><span data-stu-id="c0c10-130">**GPU** - 
 This processor most commonly handles the graphics pipeline of your application to transform 3D data (models, textures, etc) into pixels and ultimately produce a 2D image to submit to your device's screen.</span></span>

![Durée de vie d’un frame](images/lifetime-of-a-frame.png)

<span data-ttu-id="c0c10-132">En règle générale, les applications HoloLens sont limitées par GPU.</span><span class="sxs-lookup"><span data-stu-id="c0c10-132">Generally, HoloLens applications will be GPU bounded.</span></span> <span data-ttu-id="c0c10-133">Toutefois, ce n’est pas vrai dans chaque application. il est donc recommandé d’utiliser les outils & techniques ci-dessous pour obtenir une application spécifique.</span><span class="sxs-lookup"><span data-stu-id="c0c10-133">However, this does not hold true in every application and thus it is recommended to use the tools & techniques below to get to ground-truth for your particular app.</span></span>

## <a name="how-to-analyze-your-application"></a><span data-ttu-id="c0c10-134">Comment analyser votre application</span><span class="sxs-lookup"><span data-stu-id="c0c10-134">How to analyze your application</span></span>

<span data-ttu-id="c0c10-135">De nombreux outils vous permettent de comprendre le profil de performances de votre application de réalité mixte en tant que développeur.</span><span class="sxs-lookup"><span data-stu-id="c0c10-135">There are many tools that allow you as a developer to understand the performance profile of your Mixed Reality application.</span></span> <span data-ttu-id="c0c10-136">Ils vous permettront de cibler à la fois les goulots d’étranglement et la façon dont ils se manifestent pour les déboguer.</span><span class="sxs-lookup"><span data-stu-id="c0c10-136">These will enable you to both target where you have bottlenecks and how they are manifesting themselves to debug them.</span></span>

<span data-ttu-id="c0c10-137">Il s’agit d’une liste d’outils populaires et puissants pour obtenir des informations de profilage détaillés pour votre application.</span><span class="sxs-lookup"><span data-stu-id="c0c10-137">This is a list of popular and powerful tools to gain deep profiling information for your application.</span></span>
- [<span data-ttu-id="c0c10-138">Analyseurs de performances graphiques Intel</span><span class="sxs-lookup"><span data-stu-id="c0c10-138">Intel Graphics Performance Analyzers</span></span>](https://software.intel.com/gpa)
- [<span data-ttu-id="c0c10-139">Débogueurs graphiques Visual Studio</span><span class="sxs-lookup"><span data-stu-id="c0c10-139">Visual Studio Graphics Debuggers</span></span>](https://docs.microsoft.com/visualstudio/debugger/graphics/visual-studio-graphics-diagnostics?view=vs-2017)
- [<span data-ttu-id="c0c10-140">Profileur Unity</span><span class="sxs-lookup"><span data-stu-id="c0c10-140">Unity Profiler</span></span>](https://docs.unity3d.com/Manual/Profiler.html)
- [<span data-ttu-id="c0c10-141">Débogueur de frames Unity</span><span class="sxs-lookup"><span data-stu-id="c0c10-141">Unity Frame Debugger</span></span>](https://docs.unity3d.com/Manual/FrameDebugger.html)

### <a name="how-to-profile-in-any-environment"></a><span data-ttu-id="c0c10-142">Comment Profiler dans n’importe quel environnement</span><span class="sxs-lookup"><span data-stu-id="c0c10-142">How to profile in any environment</span></span>

<span data-ttu-id="c0c10-143">Un test simple permet de déterminer rapidement si vous êtes susceptible de délimiter le GPU ou d’être limité par l’UC dans votre application.</span><span class="sxs-lookup"><span data-stu-id="c0c10-143">There is a simple test to quickly determine if you are likely GPU bounded or CPU bounded in your application.</span></span> <span data-ttu-id="c0c10-144">Si vous réduisez la résolution de la sortie de la cible de rendu, il y a moins de pixels à calculer et, par conséquent, moins de travail que le GPU doit effectuer pour afficher une image.</span><span class="sxs-lookup"><span data-stu-id="c0c10-144">If you decrease the resolution of the render target output, there are less pixels to calculate and thus, less work the GPU needs to perform to render an image.</span></span> <span data-ttu-id="c0c10-145">La mise à l’échelle de la fenêtre d’affichage (mise à l’échelle dynamique) est la pratique qui consiste à rendre votre image sur une cible de rendu plus petite, alors que votre périphérique de sortie peut s’afficher.</span><span class="sxs-lookup"><span data-stu-id="c0c10-145">Viewport scaling (dynamic resolution scaling) is the practice of rendering your image to a smaller render target then your output device can display.</span></span> <span data-ttu-id="c0c10-146">L’appareil dispose de l’échantillon de l’ensemble de pixels le plus petit pour afficher votre image finale.</span><span class="sxs-lookup"><span data-stu-id="c0c10-146">The device will up-sample from the smaller set of pixels to display your final image.</span></span>

<span data-ttu-id="c0c10-147">Après une réduction de la résolution de rendu, si:</span><span class="sxs-lookup"><span data-stu-id="c0c10-147">After decreasing rendering resolution, if:</span></span>
1) <span data-ttu-id="c0c10-148">L’application de fréquence d’images **augmente**, vous êtes probablement limité par le **GPU**</span><span class="sxs-lookup"><span data-stu-id="c0c10-148">Application framerate **increases**, then you are likely **GPU Bounded**</span></span>
1) <span data-ttu-id="c0c10-149">Fréquence d’application inchangée, vous êtes probablement limité par l' **UC**</span><span class="sxs-lookup"><span data-stu-id="c0c10-149">Application framerate **unchanged**, then you are likely **CPU Bounded**</span></span>

>[!NOTE]
><span data-ttu-id="c0c10-150">Unity offre la possibilité de modifier facilement la résolution de la cible de rendu de votre application au moment de l’exécution via la propriété *[XRSettings. renderViewportScale](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)* .</span><span class="sxs-lookup"><span data-stu-id="c0c10-150">Unity provides the ability to easily modify the render target resolution of your application at runtime through the *[XRSettings.renderViewportScale](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)* property.</span></span> <span data-ttu-id="c0c10-151">La résolution de l’image finale présentée sur l’appareil est fixe.</span><span class="sxs-lookup"><span data-stu-id="c0c10-151">The final image presented on device has a fixed resolution.</span></span> <span data-ttu-id="c0c10-152">La plateforme échantillonne la sortie de résolution inférieure pour générer une image de résolution supérieure pour le rendu sur les affichages.</span><span class="sxs-lookup"><span data-stu-id="c0c10-152">The platform will sample the lower resolution output to build a higher resolution image for rendering on displays.</span></span> 
>
>```CS
>UnityEngine.XR.XRSettings.renderScale = 0.7f;
>```

## <a name="how-to-improve-your-application"></a><span data-ttu-id="c0c10-153">Comment améliorer votre application</span><span class="sxs-lookup"><span data-stu-id="c0c10-153">How to improve your application</span></span>

### <a name="cpu-performance-recommendations"></a><span data-ttu-id="c0c10-154">Recommandations relatives aux performances de l’UC</span><span class="sxs-lookup"><span data-stu-id="c0c10-154">CPU performance recommendations</span></span>

<span data-ttu-id="c0c10-155">En règle générale, la plupart des travaux dans une application de réalité mixte sur l’UC impliquent la «simulation» de la scène et le traitement d’une logique d’application unique et complète.</span><span class="sxs-lookup"><span data-stu-id="c0c10-155">Generally, most work in a mixed reality application on the CPU involves performing the "simulation" of the scene and processing extensive unique application logic.</span></span> <span data-ttu-id="c0c10-156">Par conséquent, les zones suivantes sont généralement destinées à l’optimisation.</span><span class="sxs-lookup"><span data-stu-id="c0c10-156">Thus, the following areas are usually targeted for optimization.</span></span>

- <span data-ttu-id="c0c10-157">Animations</span><span class="sxs-lookup"><span data-stu-id="c0c10-157">Animations</span></span>
- <span data-ttu-id="c0c10-158">Simplifier la physique</span><span class="sxs-lookup"><span data-stu-id="c0c10-158">Simplify Physics</span></span>
- <span data-ttu-id="c0c10-159">Allocations de mémoire</span><span class="sxs-lookup"><span data-stu-id="c0c10-159">Memory allocations</span></span>
- <span data-ttu-id="c0c10-160">Algorithmes complexes (c.-à-d.</span><span class="sxs-lookup"><span data-stu-id="c0c10-160">Complex algorithms (i.e</span></span> <span data-ttu-id="c0c10-161">cinématique inverse, recherche de chemin d’accès)</span><span class="sxs-lookup"><span data-stu-id="c0c10-161">inverse kinematics, path-finding)</span></span>

### <a name="gpu-performance-recommendations"></a><span data-ttu-id="c0c10-162">Recommandations relatives aux performances GPU</span><span class="sxs-lookup"><span data-stu-id="c0c10-162">GPU performance recommendations</span></span>

#### <a name="understanding-bandwidth-vs-fill-rate"></a><span data-ttu-id="c0c10-163">Fonctionnement de la bande passante et du taux de remplissage</span><span class="sxs-lookup"><span data-stu-id="c0c10-163">Understanding bandwidth vs fill rate</span></span>
<span data-ttu-id="c0c10-164">Lors du rendu d’une trame sur le GPU, une application est généralement limitée par la bande passante de mémoire ou le taux de remplissage.</span><span class="sxs-lookup"><span data-stu-id="c0c10-164">When rendering a frame on the GPU, an application is generally either bounded by memory bandwidth or fill rate.</span></span>

- <span data-ttu-id="c0c10-165">La **bande passante** de la mémoire est le taux de lectures et d’écritures que le GPU peut exécuter à partir de la mémoire</span><span class="sxs-lookup"><span data-stu-id="c0c10-165">**Memory bandwidth** is the rate of reads and writes the GPU can perform from memory</span></span>
    - <span data-ttu-id="c0c10-166">Pour identifier les limitations de bande passante, réduisez la qualité de la texture et vérifiez si les images sont améliorées.</span><span class="sxs-lookup"><span data-stu-id="c0c10-166">To identify bandwidth limitations, reduce texture quality and check if framerate improved.</span></span>
    - <span data-ttu-id="c0c10-167">Dans Unity, vous pouvez effectuer cette opération en modifiant la qualité de la **texture** dans **modifier** > les paramètres de la **[qualité paramètres](https://docs.unity3d.com/Manual/class-QualitySettings.html)** du**projet** > .</span><span class="sxs-lookup"><span data-stu-id="c0c10-167">In Unity, this can be done by changing **Texture Quality** in **Edit** > **Project Settings** > **[Quality Settings](https://docs.unity3d.com/Manual/class-QualitySettings.html)**.</span></span>
- <span data-ttu-id="c0c10-168">Le **taux de remplissage** fait référence au débit des pixels rendus qui peuvent être dessinés par seconde par le GPU.</span><span class="sxs-lookup"><span data-stu-id="c0c10-168">**Fill rate** refers to the throughput of rendered pixels that can be drawn per second by the GPU.</span></span>
    - <span data-ttu-id="c0c10-169">Pour identifier les limitations du taux de remplissage, diminuez la résolution de l’affichage et vérifiez si les images sont améliorées.</span><span class="sxs-lookup"><span data-stu-id="c0c10-169">To identify fill rate limitations, decrease the display resolution and check if framerate improved.</span></span> 
    - <span data-ttu-id="c0c10-170">Dans Unity, cette opération peut être effectuée via la propriété *[XRSettings. renderViewportScale](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)*</span><span class="sxs-lookup"><span data-stu-id="c0c10-170">In Unity, this can be done via the  *[XRSettings.renderViewportScale](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)* property</span></span>

<span data-ttu-id="c0c10-171">La bande passante de la mémoire implique généralement des optimisations pour</span><span class="sxs-lookup"><span data-stu-id="c0c10-171">Memory bandwidth generally involves optimizations to either</span></span>
1) <span data-ttu-id="c0c10-172">réduire les résolutions de texture</span><span class="sxs-lookup"><span data-stu-id="c0c10-172">decrease texture resolutions</span></span>
2) <span data-ttu-id="c0c10-173">Utilisez moins de textures (par exemple,</span><span class="sxs-lookup"><span data-stu-id="c0c10-173">utilize less textures (i.e</span></span> <span data-ttu-id="c0c10-174">Normals, spéculaire, etc.)</span><span class="sxs-lookup"><span data-stu-id="c0c10-174">normals, specular, etc)</span></span>

<span data-ttu-id="c0c10-175">Le taux de remplissage est principalement axé sur la réduction du nombre d’opérations qui doivent être calculées pour un pixel rendu final.</span><span class="sxs-lookup"><span data-stu-id="c0c10-175">Fill rate is primarily focused on reducing the number of operations that need to be computed for a final rendered pixel.</span></span> <span data-ttu-id="c0c10-176">Des exemples de ce qui se limitent généralement à la réduction</span><span class="sxs-lookup"><span data-stu-id="c0c10-176">Examples of this commonly fall into reducing</span></span>
1) <span data-ttu-id="c0c10-177">nombre d’objets à restituer/traiter</span><span class="sxs-lookup"><span data-stu-id="c0c10-177">number of objects to render/process</span></span>
2) <span data-ttu-id="c0c10-178">nombre d’opérations par nuanceur</span><span class="sxs-lookup"><span data-stu-id="c0c10-178">number of operations per shader</span></span>
3) <span data-ttu-id="c0c10-179">nombre d’étapes du GPU vers le résultat final (nuanceurs Geometry, effets de la postérieure au traitement, etc.)</span><span class="sxs-lookup"><span data-stu-id="c0c10-179">number of GPU stages to final result (geometry shaders, post-processing effects, etc)</span></span>
4) <span data-ttu-id="c0c10-180">nombre de pixels à afficher (c.-à-d.</span><span class="sxs-lookup"><span data-stu-id="c0c10-180">number of pixels to render (i.e</span></span> <span data-ttu-id="c0c10-181">résolution d’affichage)</span><span class="sxs-lookup"><span data-stu-id="c0c10-181">display resolution)</span></span>

#### <a name="reduce-poly-count"></a><span data-ttu-id="c0c10-182">Réduire le nombre de poly</span><span class="sxs-lookup"><span data-stu-id="c0c10-182">Reduce poly count</span></span>
<span data-ttu-id="c0c10-183">Des nombres de polygones plus élevés entraînent davantage d’opérations pour le GPU et la réduction du nombre de polygones dans votre scène réduira la durée de rendu de cette géométrie.</span><span class="sxs-lookup"><span data-stu-id="c0c10-183">Higher polygon counts result in more operations for the GPU and reducing the number of polygons in your scene will reduce the amount of time to render that geometry.</span></span> <span data-ttu-id="c0c10-184">D’autres facteurs sont impliqués dans l’ombrage de la géométrie qui peut toujours être coûteuse, mais le nombre de polygones est la mesure de base pour déterminer le coût de l’affichage d’une scène.</span><span class="sxs-lookup"><span data-stu-id="c0c10-184">There are other factors involved as well in shading the geometry that can still be expensive but polygon count is the base metric to determine how expensive a scene will be to render.</span></span>

#### <a name="limit-overdraw"></a><span data-ttu-id="c0c10-185">Limiter le surdessin</span><span class="sxs-lookup"><span data-stu-id="c0c10-185">Limit overdraw</span></span>

<span data-ttu-id="c0c10-186">Un surdessin élevé se produit lorsque plusieurs objets sont rendus mais non générés à l’écran, car ils sont masqués par un autre objet, en général plus proche de l’objet obturon.</span><span class="sxs-lookup"><span data-stu-id="c0c10-186">High overdraw occurs when multiple objects are rendered but not outputted to the screen as they are hidden by another, generally closer, occluding object.</span></span> <span data-ttu-id="c0c10-187">Imaginez qu’il s’agit d’un mur qui avait plusieurs pièces et une géométrie en arrière-plan.</span><span class="sxs-lookup"><span data-stu-id="c0c10-187">Imagine looking at a wall that had multiple rooms and geometry behind it.</span></span> <span data-ttu-id="c0c10-188">Toute la géométrie est traitée pour le rendu, mais seul le mur opaque doit vraiment être rendu, car il occludes la vue de tout autre contenu.</span><span class="sxs-lookup"><span data-stu-id="c0c10-188">All of the geometry would be processed for rendering but only the opaque wall really needs to be rendered as it occludes the view of all other content.</span></span> <span data-ttu-id="c0c10-189">Cela entraîne des opérations inutiles qui ne sont pas nécessaires pour l’affichage actuel.</span><span class="sxs-lookup"><span data-stu-id="c0c10-189">This results in wasteful operations that are not needed for the current view.</span></span>

#### <a name="shaders"></a><span data-ttu-id="c0c10-190">Nuanceurs</span><span class="sxs-lookup"><span data-stu-id="c0c10-190">Shaders</span></span>

<span data-ttu-id="c0c10-191">Les nuanceurs sont de petits programmes qui s’exécutent sur le GPU et déterminent généralement deux étapes importantes du rendu:</span><span class="sxs-lookup"><span data-stu-id="c0c10-191">Shaders are small programs that run on the GPU and generally determine two important steps in rendering:</span></span>
1) <span data-ttu-id="c0c10-192">les sommets de l’objet qui doivent être dessinés à l’écran et l’emplacement où ils se trouvent dans l’espace à l’écran (c.-à-d.</span><span class="sxs-lookup"><span data-stu-id="c0c10-192">which object's vertices should be drawn on the screen and where they are in screen space (i.e</span></span> <span data-ttu-id="c0c10-193">nuanceur de sommets)</span><span class="sxs-lookup"><span data-stu-id="c0c10-193">the Vertex shader)</span></span>
    - <span data-ttu-id="c0c10-194">Le nuanceur vertex est généralement exécuté par vertex pour chaque GameObject</span><span class="sxs-lookup"><span data-stu-id="c0c10-194">The Vertex shader is generally executed per vertex for every GameObject</span></span>
2) <span data-ttu-id="c0c10-195">comment colorer ces pixels (c.-à-d.</span><span class="sxs-lookup"><span data-stu-id="c0c10-195">what to color those pixels (i.e</span></span> <span data-ttu-id="c0c10-196">nuanceur de pixels)</span><span class="sxs-lookup"><span data-stu-id="c0c10-196">the Pixel shader)</span></span>
    - <span data-ttu-id="c0c10-197">Le nuanceur de pixels est exécuté par pixel pour la texture rendue pour l’appareil présent</span><span class="sxs-lookup"><span data-stu-id="c0c10-197">The Pixel shader is executed per pixel for the texture being rendered for device present</span></span>

<span data-ttu-id="c0c10-198">En général, les nuanceurs effectuent de nombreuses transformations et des calculs d’éclairage.</span><span class="sxs-lookup"><span data-stu-id="c0c10-198">Typically shaders perform many transformations and lighting calculations.</span></span> <span data-ttu-id="c0c10-199">Bien que les modèles d’éclairage complexes, les ombres et les autres opérations puissent générer des résultats fantastiques, ils sont également fournis avec un prix.</span><span class="sxs-lookup"><span data-stu-id="c0c10-199">Although complex lighting models, shadows, and other operations can generate fantastic results, they also come with a price.</span></span> <span data-ttu-id="c0c10-200">La réduction du nombre d’opérations calculées dans les nuanceurs peut réduire considérablement le travail global nécessaire à la réalisation d’un GPU par trame.</span><span class="sxs-lookup"><span data-stu-id="c0c10-200">Reducing the number of operations computed in shaders can greatly reduce the overall work needed to be done by a GPU per frame.</span></span>

##### <a name="shader-coding-recommendations"></a><span data-ttu-id="c0c10-201">Recommandations en matière de codage de nuanceur</span><span class="sxs-lookup"><span data-stu-id="c0c10-201">Shader coding recommendations</span></span>

- <span data-ttu-id="c0c10-202">Utiliser le filtrage bilinéaire dans la mesure du possible</span><span class="sxs-lookup"><span data-stu-id="c0c10-202">Use bilinear filtering whenever possible</span></span>
- <span data-ttu-id="c0c10-203">Réorganiser les expressions pour utiliser des intrinsèques MAD afin d’effectuer une multiplication et un ajout en même temps</span><span class="sxs-lookup"><span data-stu-id="c0c10-203">Rearrange expressions to use MAD intrinsics in order to do a multiply and an add at the same time</span></span>
- <span data-ttu-id="c0c10-204">Précalculez autant que possible sur le processeur et transmettez-les en tant que constantes au matériel.</span><span class="sxs-lookup"><span data-stu-id="c0c10-204">Precalculate as much as possible on the CPU and pass as constants to the material</span></span>
- <span data-ttu-id="c0c10-205">**Privilégier les opérations de déplacement du nuanceur de pixels vers le nuanceur de sommets**</span><span class="sxs-lookup"><span data-stu-id="c0c10-205">**Favor moving operations from the pixel shader to the vertex shader**</span></span>
    - <span data-ttu-id="c0c10-206">En général, le nombre de vertex < < nombre de pixels (c.-à-d.</span><span class="sxs-lookup"><span data-stu-id="c0c10-206">Generally the # of vertices << # of pixels (i.e</span></span> <span data-ttu-id="c0c10-207">720p = = 921 600 pixels, 1080p = = 2 073 600 pixels, etc.)</span><span class="sxs-lookup"><span data-stu-id="c0c10-207">720p == 921,600 pixels, 1080p == 2,073,600 pixels, etc)</span></span>

#### <a name="remove-gpu-stages"></a><span data-ttu-id="c0c10-208">Supprimer les étapes du GPU</span><span class="sxs-lookup"><span data-stu-id="c0c10-208">Remove GPU stages</span></span>
<span data-ttu-id="c0c10-209">Les effets de la postérieure au traitement peuvent être très coûteux et, en général, inhiber le taux de remplissage de votre application.</span><span class="sxs-lookup"><span data-stu-id="c0c10-209">Post-processing effects can be very expensive and generally inhibit the fill rate of your application.</span></span> <span data-ttu-id="c0c10-210">Cela comprend également des techniques d’anticrénelage telles que MSAA.</span><span class="sxs-lookup"><span data-stu-id="c0c10-210">This also includes anti-aliasing techniques such as MSAA.</span></span> <span data-ttu-id="c0c10-211">Sur HoloLens, il est recommandé d’éviter ces techniques entièrement.</span><span class="sxs-lookup"><span data-stu-id="c0c10-211">On HoloLens, it is recommended to avoid these techniques entirely.</span></span> <span data-ttu-id="c0c10-212">En outre, des étapes de nuanceur supplémentaires, telles que Geometry, coque et les nuanceurs de calcul, doivent être évitées lorsque cela est possible.</span><span class="sxs-lookup"><span data-stu-id="c0c10-212">Furthermore, additional shader stages such as geometry, hull, and compute shaders should be avoided when possible.</span></span>

## <a name="memory-recommendations"></a><span data-ttu-id="c0c10-213">Recommandations de mémoire</span><span class="sxs-lookup"><span data-stu-id="c0c10-213">Memory recommendations</span></span>
<span data-ttu-id="c0c10-214">L’allocation de mémoire excessive & les opérations de désallocation peuvent avoir des effets négatifs sur votre application holographique, ce qui se traduit par des performances incohérentes, des trames figées et d’autres comportements nuisibles.</span><span class="sxs-lookup"><span data-stu-id="c0c10-214">Excessive memory allocation & deallocation operations can have adverse effects on your holographic application resulting in inconsistent performance, frozen frames, and other detrimental behavior.</span></span> <span data-ttu-id="c0c10-215">Il est particulièrement important de comprendre les considérations relatives à la mémoire lors du développement dans Unity, car la gestion de la mémoire est contrôlée par le garbage collector.</span><span class="sxs-lookup"><span data-stu-id="c0c10-215">It is especially important to understand memory considerations when developing in Unity since memory management is controlled by the garbage collector.</span></span>

#### <a name="object-pooling"></a><span data-ttu-id="c0c10-216">Mise en pool d’objets</span><span class="sxs-lookup"><span data-stu-id="c0c10-216">Object pooling</span></span>

<span data-ttu-id="c0c10-217">Le mise en pool d’objets est une technique populaire pour réduire le coût des allocations continues & des désallocations d’objets.</span><span class="sxs-lookup"><span data-stu-id="c0c10-217">Object pooling is a popular technique to reduce the cost of continuous allocations & deallocations of objects.</span></span> <span data-ttu-id="c0c10-218">Pour ce faire, vous devez allouer un grand pool d’objets identiques et réutiliser les instances inactives de ce pool au lieu de générer et de détruire constamment des objets dans le temps.</span><span class="sxs-lookup"><span data-stu-id="c0c10-218">This is done by allocating a large pool of identical objects and re-using inactive, available instances from this pool instead of constantly spawning and destroying objects over time.</span></span> <span data-ttu-id="c0c10-219">Les pools d’objets sont idéaux pour les composants réutilisables qui ont une durée de vie variable pendant une application.</span><span class="sxs-lookup"><span data-stu-id="c0c10-219">Object pools are great for re-useable components that have variable lifetime during an app.</span></span>

## <a name="see-also"></a><span data-ttu-id="c0c10-220">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="c0c10-220">See also</span></span>
- [<span data-ttu-id="c0c10-221">Recommandations de performances pour Unity</span><span class="sxs-lookup"><span data-stu-id="c0c10-221">Performance recommendations for Unity</span></span>](performance-recommendations-for-unity.md)
- [<span data-ttu-id="c0c10-222">Paramètres recommandés pour Unity</span><span class="sxs-lookup"><span data-stu-id="c0c10-222">Recommended settings for Unity</span></span>](recommended-settings-for-unity.md)
