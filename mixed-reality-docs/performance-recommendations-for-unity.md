---
title: Recommandations en matière de performances pour Unity
description: Conseils spécifiques à Unity pour améliorer les performances avec des applications de réalité mixte.
author: Troy-Ferrell
ms.author: trferrel
ms.date: 03/26/2019
ms.topic: article
keywords: graphiques, UC, GPU, rendu, garbage collection, hololens
ms.openlocfilehash: 6507667904cfa26dfad1ccf1402cc75f14386609
ms.sourcegitcommit: 9005b3fdfa87ac8fdc18a594a681e25c00ac5ce1
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 12/11/2019
ms.locfileid: "75003198"
---
# <a name="performance-recommendations-for-unity"></a><span data-ttu-id="1d0e8-104">Recommandations en matière de performances pour Unity</span><span class="sxs-lookup"><span data-stu-id="1d0e8-104">Performance recommendations for Unity</span></span>

<span data-ttu-id="1d0e8-105">Cet article s’appuie sur la discussion présentée dans [recommandations de performances pour la réalité mixte](understanding-performance-for-mixed-reality.md) , mais se concentre sur les apprentissages spécifiques à l’environnement du moteur Unity.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-105">This article builds on the discussion outlined in [performance recommendations for mixed reality](understanding-performance-for-mixed-reality.md) but focuses on learnings specific to the Unity engine environment.</span></span>

<span data-ttu-id="1d0e8-106">Il est également vivement conseillé aux développeurs de passer en revue les [paramètres d’environnement recommandés pour l’article Unity](Recommended-settings-for-unity.md).</span><span class="sxs-lookup"><span data-stu-id="1d0e8-106">It is also highly advisable that developers review the [recommended environment settings for Unity article](Recommended-settings-for-unity.md).</span></span> <span data-ttu-id="1d0e8-107">Cet article contient du contenu avec certaines des configurations de scène les plus importantes pour créer des applications de réalité mixte performantes.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-107">This article contains content with some of the most important scene configurations for building performant Mixed Reality apps.</span></span> <span data-ttu-id="1d0e8-108">Certains de ces paramètres recommandés sont également mis en surbrillance ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-108">Some of these recommended settings are highlighted below, as well.</span></span>

## <a name="how-to-profile-with-unity"></a><span data-ttu-id="1d0e8-109">Profilage avec Unity</span><span class="sxs-lookup"><span data-stu-id="1d0e8-109">How to profile with Unity</span></span>

<span data-ttu-id="1d0e8-110">Unity fournit le **[profileur Unity](https://docs.unity3d.com/Manual/Profiler.html)** , qui est une excellente ressource permettant de recueillir des informations de performances précieuses pour votre application.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-110">Unity provides the **[Unity Profiler](https://docs.unity3d.com/Manual/Profiler.html)** built-in, which is a great resource to gather valuable performance insights for your particular app.</span></span> <span data-ttu-id="1d0e8-111">Bien qu’il soit possible d’exécuter le profileur dans l’éditeur, ces mesures ne représentent pas l’environnement d’exécution réel et, par conséquent, les résultats de ce doivent être utilisés avec prudence.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-111">Although one can run the profiler in-editor, these metrics do not represent the true runtime environment and thus, results from this should be used cautiously.</span></span> <span data-ttu-id="1d0e8-112">Nous vous recommandons de profiler à distance votre application en cours d’exécution sur l’appareil pour obtenir des informations plus précises et exploitables.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-112">It is recommended to remotely profile your application while running on device for most accurate and actionable insights.</span></span> <span data-ttu-id="1d0e8-113">En outre, le [débogueur de frames](https://docs.unity3d.com/Manual/FrameDebugger.html) Unity est également un outil très puissant et d’analyse à utiliser.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-113">Further, Unity's [Frame Debugger](https://docs.unity3d.com/Manual/FrameDebugger.html) is also a very powerful and insight tool to utilize.</span></span>

<span data-ttu-id="1d0e8-114">Unity fournit une documentation très utile pour :</span><span class="sxs-lookup"><span data-stu-id="1d0e8-114">Unity provides great documentation for:</span></span>
1) <span data-ttu-id="1d0e8-115">Comment connecter le [profileur Unity aux applications UWP à distance](https://docs.unity3d.com/Manual/windowsstore-profiler.html)</span><span class="sxs-lookup"><span data-stu-id="1d0e8-115">How to connect the [Unity profiler to UWP applications remotely](https://docs.unity3d.com/Manual/windowsstore-profiler.html)</span></span>
2) <span data-ttu-id="1d0e8-116">Comment [diagnostiquer efficacement les problèmes de performances avec le profileur Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/diagnosing-performance-problems-using-profiler-window)</span><span class="sxs-lookup"><span data-stu-id="1d0e8-116">How to effectively [diagnose performance problems with the Unity Profiler](https://unity3d.com/learn/tutorials/temas/performance-optimization/diagnosing-performance-problems-using-profiler-window)</span></span>

>[!NOTE]
> <span data-ttu-id="1d0e8-117">Lorsque le profileur Unity est connecté et après l’ajout du profileur GPU (voir *Ajouter le profileur* dans l’angle supérieur droit), vous pouvez voir le temps passé sur le processeur & GPU, respectivement au milieu du profileur.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-117">With the Unity Profiler connected and after adding the GPU profiler (see *Add Profiler* in top right corner), one can see how much time is being spent on the CPU & GPU respectively in the middle of the profiler.</span></span> <span data-ttu-id="1d0e8-118">Cela permet au développeur d’obtenir une approximation rapide si son application est liée à l’UC ou au GPU.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-118">This allows the developer to get a quick approximation if their application is CPU or GPU bounded.</span></span>
>
> ![UC et GPU Unity](images/unity-profiler-cpu-gpu.png)

## <a name="cpu-performance-recommendations"></a><span data-ttu-id="1d0e8-120">Recommandations relatives aux performances de l’UC</span><span class="sxs-lookup"><span data-stu-id="1d0e8-120">CPU performance recommendations</span></span>

<span data-ttu-id="1d0e8-121">Le contenu ci-dessous couvre des pratiques de performances plus approfondies, en C# particulier destinées au développement & Unity.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-121">The content below covers more in-depth performance practices, especially targeted for Unity & C# development.</span></span>

#### <a name="cache-references"></a><span data-ttu-id="1d0e8-122">Références du cache</span><span class="sxs-lookup"><span data-stu-id="1d0e8-122">Cache references</span></span>

<span data-ttu-id="1d0e8-123">Il est recommandé de mettre en cache les références à tous les composants et GameObjects pertinents lors de l’initialisation.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-123">It is best practice to cache references to all relevant components and GameObjects at initialization.</span></span> <span data-ttu-id="1d0e8-124">Cela est dû au fait que les appels de fonction répétitifs, tels que *[GetComponent\<t > ()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* , sont beaucoup plus coûteux par rapport au coût de mémoire pour stocker un pointeur.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-124">This is because repeating function calls such as *[GetComponent\<T>()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* are significantly more expensive relative to the memory cost to store a pointer.</span></span> <span data-ttu-id="1d0e8-125">Cela s’applique également à l' [appareil photo. main](https://docs.unity3d.com/ScriptReference/Camera-main.html)régulièrement utilisé.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-125">This also applies to to the very regularly used [Camera.main](https://docs.unity3d.com/ScriptReference/Camera-main.html).</span></span> <span data-ttu-id="1d0e8-126">*Camera. main* utilise en fait simplement *[FindGameObjectsWithTag ()](https://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html)* en-dessous, ce qui effectue une recherche coûteuse dans votre graphique de scène pour un objet Camera avec la balise *« MainCamera »* .</span><span class="sxs-lookup"><span data-stu-id="1d0e8-126">*Camera.main* actually just uses *[FindGameObjectsWithTag()](https://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html)* underneath, which expensively searches your scene graph for a camera object with the *"MainCamera"* tag.</span></span>

```CS
using UnityEngine;
using System.Collections;

public class ExampleClass : MonoBehaviour
{
    private Camera cam;
    private CustomComponent comp;

    void Start() 
    {
        cam = Camera.main;
        comp = GetComponent<CustomComponent>();
    }

    void Update()
    {
        // Good
        this.transform.position = cam.transform.position + cam.transform.forward * 10.0f;

        // Bad
        this.transform.position = Camera.main.transform.position + Camera.main.transform.forward * 10.0f;

        // Good
        comp.DoSomethingAwesome();

        // Bad
        GetComponent<CustomComponent>().DoSomethingAwesome();
    }
}
```

>[!NOTE] 
> <span data-ttu-id="1d0e8-127">Évitez GetComponent (String)</span><span class="sxs-lookup"><span data-stu-id="1d0e8-127">Avoid GetComponent(string)</span></span> <br/>
> <span data-ttu-id="1d0e8-128">Lors de l’utilisation de *[GetComponent ()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* , il existe un certain nombre de surcharges différentes.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-128">When using *[GetComponent()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)*, there are a handful of different overloads.</span></span> <span data-ttu-id="1d0e8-129">Il est important de toujours utiliser les implémentations basées sur le type et jamais la surcharge de recherche basée sur chaîne.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-129">It is important to always use the Type-based implementations and never the string-based searching overload.</span></span> <span data-ttu-id="1d0e8-130">La recherche par chaîne dans votre scène est beaucoup plus coûteuse que la recherche par type.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-130">Searching by string in your scene is significantly more costly than searching by Type.</span></span> <br/>
> <span data-ttu-id="1d0e8-131">État GetComponent composant (type type)</span><span class="sxs-lookup"><span data-stu-id="1d0e8-131">(Good) Component GetComponent(Type type)</span></span> <br/>
> <span data-ttu-id="1d0e8-132">État T GetComponent\<T > ()</span><span class="sxs-lookup"><span data-stu-id="1d0e8-132">(Good) T GetComponent\<T>()</span></span> <br/>
> <span data-ttu-id="1d0e8-133">Incorrecte GetComponent du composant (chaîne) ></span><span class="sxs-lookup"><span data-stu-id="1d0e8-133">(Bad) Component GetComponent(string)></span></span> <br/>

#### <a name="avoid-expensive-operations"></a><span data-ttu-id="1d0e8-134">Évitez les opérations coûteuses</span><span class="sxs-lookup"><span data-stu-id="1d0e8-134">Avoid expensive operations</span></span>

1) <span data-ttu-id="1d0e8-135">**Éviter l’utilisation de [LINQ](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/getting-started-with-linq)**</span><span class="sxs-lookup"><span data-stu-id="1d0e8-135">**Avoid use of [LINQ](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/getting-started-with-linq)**</span></span>

    <span data-ttu-id="1d0e8-136">Même si LINQ peut être très propre et facile à lire et à écrire, il requiert généralement beaucoup plus de calculs et plus particulièrement plus d’allocation de mémoire que l’écriture manuelle de l’algorithme.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-136">Although LINQ can be very clean and easy to read and write, it generally requires much more computation and particularly more memory allocation than writing the algorithm out manually.</span></span>

    ```CS
    // Example Code
    using System.Linq;

    List<int> data = new List<int>();
    data.Any(x => x > 10);

    var result = from x in data
                 where x > 10
                 select x;
    ```

2) <span data-ttu-id="1d0e8-137">**API Unity courantes**</span><span class="sxs-lookup"><span data-stu-id="1d0e8-137">**Common Unity APIs**</span></span>

    <span data-ttu-id="1d0e8-138">Certaines API Unity, bien qu’utiles, peuvent être très chères à s’exécuter.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-138">Certain Unity APIs, although useful, can be very expensive to execute.</span></span> <span data-ttu-id="1d0e8-139">La plupart d’entre elles impliquent la recherche d’une liste de GameObjects correspondante dans l’ensemble du graphique de scène.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-139">Most of these involve searching your entire scene graph for some matching list of GameObjects.</span></span> <span data-ttu-id="1d0e8-140">Ces opérations peuvent généralement être évitées en mettant en cache des références ou en implémentant un composant de gestionnaire pour le GameObjects en question pour suivre les références au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-140">These operations can generally be avoided by caching references or implementing a manager component for the GameObjects in question to track the references at runtime.</span></span>

        GameObject.SendMessage()
        GameObject.BroadcastMessage()
        UnityEngine.Object.Find()
        UnityEngine.Object.FindWithTag()
        UnityEngine.Object.FindObjectOfType()
        UnityEngine.Object.FindObjectsOfType()
        UnityEngine.Object.FindGameObjectsWithTag()
        UnityEngine.Object.FindGameObjectsWithTag()

>[!NOTE]
> <span data-ttu-id="1d0e8-141">*[SendMessage ()](https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html)* et *[BroadcastMessage ()](https://docs.unity3d.com/ScriptReference/GameObject.BroadcastMessage.html)* doivent être éliminés à tout prix.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-141">*[SendMessage()](https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html)* and *[BroadcastMessage()](https://docs.unity3d.com/ScriptReference/GameObject.BroadcastMessage.html)* should be eliminated at all costs.</span></span> <span data-ttu-id="1d0e8-142">Ces fonctions peuvent être dans l’ordre de 1 000 fois plus lentes que les appels de fonction directs.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-142">These functions can be on the order of 1000x slower than direct function calls.</span></span>

3) <span data-ttu-id="1d0e8-143">**Méfiez-vous du Boxing**</span><span class="sxs-lookup"><span data-stu-id="1d0e8-143">**Beware of boxing**</span></span>

    <span data-ttu-id="1d0e8-144">La C# [conversion boxing](https://docs.microsoft.com/dotnet/csharp/programming-guide/types/boxing-and-unboxing) est un concept fondamental du langage et du Runtime.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-144">[Boxing](https://docs.microsoft.com/dotnet/csharp/programming-guide/types/boxing-and-unboxing) is a core concept of the C# language and runtime.</span></span> <span data-ttu-id="1d0e8-145">C’est le processus qui consiste à encapsuler des variables de type valeur, telles que Char, int, bool, etc., dans des variables de type référence.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-145">It is the process of wrapping value-typed variables such as char, int, bool, etc. into reference-typed variables.</span></span> <span data-ttu-id="1d0e8-146">Quand une variable de type valeur est « boxed », elle est encapsulée à l’intérieur d’un System. Object qui est stocké sur le tas managé.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-146">When a value-typed variable is "boxed", it is wrapped inside of a System.Object which is stored on the managed heap.</span></span> <span data-ttu-id="1d0e8-147">Par conséquent, la mémoire est allouée et, quand elle est supprimée, elle doit être traitée par le garbage collector.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-147">Thus, memory is allocated and eventually when disposed must be processed by the garbage collector.</span></span> <span data-ttu-id="1d0e8-148">Ces allocations et désallocations entraînent un coût de performance et, dans de nombreux scénarios, sont inutiles ou peuvent être facilement remplacées par une alternative moins coûteuse.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-148">These allocations and deallocations incur a performance cost and in many scenarios are unnecessary or can be easily replaced by a less expensive alternative.</span></span>

    <span data-ttu-id="1d0e8-149">L’une des formes les plus courantes de boxing dans le développement est l’utilisation de [types valeur Nullable](https://docs.microsoft.com//dotnet/csharp/programming-guide/nullable-types/).</span><span class="sxs-lookup"><span data-stu-id="1d0e8-149">One of the most common forms of boxing in development is the use of [nullable value types](https://docs.microsoft.com//dotnet/csharp/programming-guide/nullable-types/).</span></span> <span data-ttu-id="1d0e8-150">Il est courant de vouloir retourner null pour un type valeur dans une fonction, en particulier lorsque l’opération peut échouer en tentant d’obtenir la valeur.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-150">It is common to want to be able to return null for a value type in a function, especially when the operation may fail trying to get the value.</span></span> <span data-ttu-id="1d0e8-151">Le problème potentiel de cette approche est que l’allocation se produit maintenant sur le tas et doit donc être récupérée par le garbage collector ultérieurement.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-151">The potential problem with this approach is that allocation now occurs on the heap and consequently needs to be garbage collected later.</span></span>

    <span data-ttu-id="1d0e8-152">**Exemple de boxing dansC#**</span><span class="sxs-lookup"><span data-stu-id="1d0e8-152">**Example of boxing in C#**</span></span>

    ```csharp
    // boolean value type is boxed into object boxedMyVar on the heap
    bool myVar = true;
    object boxedMyVar = myVar;
    ```

    <span data-ttu-id="1d0e8-153">**Exemple de boxing problématique via les types valeur Nullable**</span><span class="sxs-lookup"><span data-stu-id="1d0e8-153">**Example of problematic boxing via nullable value types**</span></span>

    <span data-ttu-id="1d0e8-154">Ce code illustre une classe de particule factice qu’il est possible de créer dans un projet Unity.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-154">This code demonstrates a dummy particle class that one may create in a Unity project.</span></span> <span data-ttu-id="1d0e8-155">Un appel à `TryGetSpeed()` entraîne l’allocation d’objets sur le tas qui devra être récupéré par le garbage collector ultérieurement.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-155">A call to `TryGetSpeed()` will cause object allocation on the heap which will need to be garbage collected at a later point in time.</span></span> <span data-ttu-id="1d0e8-156">Cet exemple est particulièrement problématique, car il peut y avoir plus de 1000 particules dans une scène, chacune étant demandée pour la vitesse actuelle.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-156">This example is particularly problematic as there may be 1000+ or many more particles in a scene, each being asked for their current speed.</span></span> <span data-ttu-id="1d0e8-157">Par conséquent, 1 000 d’objets seraient alloués et, par conséquent, désalloués à chaque trame, ce qui aurait beaucoup diminué les performances.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-157">Thus, 1000's of objects would be allocated and consequently de-allocated every frame, which would greatly diminish performance.</span></span> <span data-ttu-id="1d0e8-158">La réécriture de la fonction pour retourner une valeur négative telle que-1 pour indiquer qu’un échec peut éviter ce problème et conserver la mémoire sur la pile.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-158">Re-writing the function to return a negative value such as -1 to indicate a failure would avoid this issue and keep memory on the stack.</span></span>

    ```csharp
        public class MyParticle
        {
            // Example of function returning nullable value type
            public int? TryGetSpeed()
            {
                // Returns current speed int value or null if fails
            }
        }
    ```

#### <a name="repeating-code-paths"></a><span data-ttu-id="1d0e8-159">Répéter les chemins de code</span><span class="sxs-lookup"><span data-stu-id="1d0e8-159">Repeating code paths</span></span>

<span data-ttu-id="1d0e8-160">Toutes les fonctions de rappel Unity répétitives (c.-à-d.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-160">Any repeating Unity callback functions (i.e</span></span> <span data-ttu-id="1d0e8-161">Update) qui sont exécutées plusieurs fois par seconde et/ou que le frame doit être écrit très attentivement.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-161">Update) that are executed many times per second and/or frame should be written very carefully.</span></span> <span data-ttu-id="1d0e8-162">Toutes les opérations coûteuses ici auront un impact énorme et cohérent sur les performances.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-162">Any expensive operations here will have huge and consistent impact on performance.</span></span>

1) <span data-ttu-id="1d0e8-163">**Fonctions de rappel vides**</span><span class="sxs-lookup"><span data-stu-id="1d0e8-163">**Empty callback functions**</span></span>

    <span data-ttu-id="1d0e8-164">Bien que le code ci-dessous puisse paraître inoffensif dans votre application, en particulier puisque chaque script Unity s’initialise automatiquement avec ce bloc de code, ces rappels vides peuvent en fait devenir très coûteux.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-164">Although the code below may seem innocent to leave in your application, especially since every Unity script auto-initializes with this code block, these empty callbacks can actually become very expensive.</span></span> <span data-ttu-id="1d0e8-165">Unity fonctionne de façon alternée par rapport à une limite de code non managé/managé, entre le code UnityEngine et votre code d’application.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-165">Unity operates back and forth over an unmanaged/managed code boundary, between UnityEngine code and your application code.</span></span> <span data-ttu-id="1d0e8-166">Le changement de contexte sur ce pont est assez onéreux, même s’il n’y a rien à exécuter.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-166">Context switching over this bridge is fairly expensive, even if there is nothing to execute.</span></span> <span data-ttu-id="1d0e8-167">Cela devient particulièrement problématique si votre application a 100 GameObjects avec des composants qui ont des rappels Unity répétitifs vides.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-167">This becomes especially problematic if your app has 100's of GameObjects with components that have empty repeating Unity callbacks.</span></span>

    ```CS
    void Update()
    {
    }
    ```

>[!NOTE]
> <span data-ttu-id="1d0e8-168">Update () est la manifestation la plus courante de ce problème de performance, mais d’autres rappels Unity répétitifs, tels que les suivants peuvent être aussi mauvais, si ce n’est pas pire : FixedUpdate (), LateUpdate (), OnPostRender», OnPreRender (), OnRenderImage (), etc.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-168">Update() is the most common manifestation of this performance issue but other repeating Unity callbacks, such as the following can be equally as bad, if not worse: FixedUpdate(), LateUpdate(), OnPostRender", OnPreRender(), OnRenderImage(), etc.</span></span> 

2) <span data-ttu-id="1d0e8-169">**Opérations à privilégier en cours d’exécution par frame**</span><span class="sxs-lookup"><span data-stu-id="1d0e8-169">**Operations to favor running once per frame**</span></span>

    <span data-ttu-id="1d0e8-170">Les API Unity suivantes sont des opérations courantes pour de nombreuses applications holographiques.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-170">The following Unity APIs are common operations for many Holographic Apps.</span></span> <span data-ttu-id="1d0e8-171">Bien que cela ne soit pas toujours possible, les résultats de ces fonctions peuvent être souvent calculés une fois et les résultats réutilisés dans l’application pour une trame donnée.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-171">Although not always possible, the results from these functions can very commonly be computed once and the results re-utilized across the application for a given frame.</span></span>

    <span data-ttu-id="1d0e8-172">r. en général, il est recommandé de disposer d’une classe ou d’un service Singleton dédié pour gérer votre Raycast de pointage dans la scène, puis de réutiliser ce résultat dans tous les autres composants de scène, au lieu d’effectuer des opérations Raycast répétées et fondamentalement identiques pour chaque -.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-172">a) Generally it is good practice to have a dedicated Singleton class or service to handle your gaze Raycast into the scene and then re-use this result in all other scene components, instead of making repeated and essentially identical Raycast operations by each component.</span></span> <span data-ttu-id="1d0e8-173">Bien entendu, certaines applications peuvent nécessiter des raycasts provenant de différentes origines ou de différentes [LayerMasks](https://docs.unity3d.com/ScriptReference/LayerMask.html).</span><span class="sxs-lookup"><span data-stu-id="1d0e8-173">Of course, some applications may require raycasts from different origins or against different [LayerMasks](https://docs.unity3d.com/ScriptReference/LayerMask.html).</span></span>

        UnityEngine.Physics.Raycast()
        UnityEngine.Physics.RaycastAll()

    <span data-ttu-id="1d0e8-174">b) Évitez les opérations GetComponent () dans les rappels Unity répétés tels que Update () en [mettant en cache les références](#cache-references) dans START () ou éveillé ()</span><span class="sxs-lookup"><span data-stu-id="1d0e8-174">b) Avoid GetComponent() operations in repeated Unity callbacks like Update() by [caching references](#cache-references) in Start() or Awake()</span></span>

        UnityEngine.Object.GetComponent()

    <span data-ttu-id="1d0e8-175">c) il est recommandé d’instancier tous les objets, si possible, lors de l’initialisation et utiliser le [pool d’objets](#object-pooling) pour recycler et réutiliser les GameObjects tout au long de l’exécution de votre application</span><span class="sxs-lookup"><span data-stu-id="1d0e8-175">c) It is good practice to instantiate all objects, if possible, at initialization and use [object pooling](#object-pooling) to recycle and re-use GameObjects throughout runtime of your application</span></span>

        UnityEngine.Object.Instantiate()

3) <span data-ttu-id="1d0e8-176">**Évitez les interfaces et les constructions virtuelles**</span><span class="sxs-lookup"><span data-stu-id="1d0e8-176">**Avoid interfaces and virtual constructs**</span></span>

    <span data-ttu-id="1d0e8-177">L’appel d’appels de fonction via des interfaces et des objets directs ou l’appel de fonctions virtuelles peut souvent être beaucoup plus coûteux que l’utilisation de constructions directes ou d’appels de fonction directs.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-177">Invoking function calls through interfaces vs direct objects or calling virtual functions can often times be much more expensive than utilizing direct constructs or direct function calls.</span></span> <span data-ttu-id="1d0e8-178">Si la fonction ou l’interface virtuelle n’est pas nécessaire, elle doit être supprimée.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-178">If the virtual function or interface is unnecessary, then it should be removed.</span></span> <span data-ttu-id="1d0e8-179">Toutefois, l’impact sur les performances de ces approches est généralement plus intéressant si leur utilisation simplifie la collaboration au développement, la lisibilité du code et la maintenabilité du code.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-179">However, the performance hit for these approaches are generally worth the trade-off if utilizing them simplifies development collaboration, code readability, and code maintainability.</span></span>

    <span data-ttu-id="1d0e8-180">En règle générale, il est recommandé de ne pas marquer les champs et les fonctions comme virtuels, à moins qu’il y ait une attente claire que ce membre doive être remplacé.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-180">Generally, the recommendation is to not mark fields and functions as virtual unless there is a clear expectation that this member needs to be overwritten.</span></span> <span data-ttu-id="1d0e8-181">L’un d’eux doit être particulièrement attentif aux chemins de code à haute fréquence qui sont appelés plusieurs fois par trame, ou même une fois par Frame, par exemple une méthode de `UpdateUI()`.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-181">One should be especially careful around high-frequency code paths that are called many times per frame or even once per frame such as an `UpdateUI()` method.</span></span>

4) <span data-ttu-id="1d0e8-182">**Évitez de passer des structs par valeur**</span><span class="sxs-lookup"><span data-stu-id="1d0e8-182">**Avoid passing structs by value**</span></span>

    <span data-ttu-id="1d0e8-183">Contrairement aux classes, les structs sont des types valeur et lorsqu’ils sont passés directement à une fonction, leur contenu est copié dans une instance nouvellement créée.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-183">Unlike classes, structs are value-types and when passed directly to a function, their contents are copied into a newly created instance.</span></span> <span data-ttu-id="1d0e8-184">Cette copie ajoute le coût de l’UC, ainsi que la mémoire supplémentaire sur la pile.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-184">This copy adds CPU cost, as well as additional memory on the stack.</span></span> <span data-ttu-id="1d0e8-185">Pour les petits structs, l’effet est généralement très minime et donc acceptable.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-185">For small structs, the effect is usually very minimal and thus acceptable.</span></span> <span data-ttu-id="1d0e8-186">Toutefois, pour les fonctions appelées à plusieurs reprises à chaque trame ainsi que les fonctions acceptant des structures volumineuses, si possible, modifiez la définition de fonction pour qu’elle passe par référence.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-186">However, for functions repeatedly invoked every frame as well as functions taking large structs, if possible modify the function definition to pass by reference.</span></span> [<span data-ttu-id="1d0e8-187">En savoir plus ici</span><span class="sxs-lookup"><span data-stu-id="1d0e8-187">Learn more here</span></span>](https://docs.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/how-to-know-the-difference-passing-a-struct-and-passing-a-class-to-a-method)

#### <a name="miscellaneous"></a><span data-ttu-id="1d0e8-188">Divers</span><span class="sxs-lookup"><span data-stu-id="1d0e8-188">Miscellaneous</span></span>

1) <span data-ttu-id="1d0e8-189">**Physique**</span><span class="sxs-lookup"><span data-stu-id="1d0e8-189">**Physics**</span></span>

    <span data-ttu-id="1d0e8-190">r) en règle générale, le moyen le plus simple d’améliorer la physique consiste à limiter le temps consacré à la physique ou au nombre d’itérations par seconde.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-190">a) Generally, the easiest way to improve physics is to limit the amount of time spent on Physics or the number of iterations per second.</span></span> <span data-ttu-id="1d0e8-191">Bien entendu, cela permet de réduire la précision de la simulation.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-191">Of course, this will reduce simulation accuracy.</span></span> <span data-ttu-id="1d0e8-192">Voir [timemanager](https://docs.unity3d.com/Manual/class-TimeManager.html) dans Unity</span><span class="sxs-lookup"><span data-stu-id="1d0e8-192">See [TimeManager](https://docs.unity3d.com/Manual/class-TimeManager.html) in Unity</span></span>

    <span data-ttu-id="1d0e8-193">b) le type de conflits dans Unity a des caractéristiques de performances très différentes.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-193">b) The type of colliders in Unity have widely different performance characteristics.</span></span> <span data-ttu-id="1d0e8-194">L’ordre ci-dessous répertorie les conflits les plus performants pour les conflits les plus performants, de gauche à droite.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-194">The order below lists the most performant colliders to least performant colliders from left to right.</span></span> <span data-ttu-id="1d0e8-195">Il est plus important d’éviter les conflits de maille, qui sont beaucoup plus chers que les conflits primitifs.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-195">It is most important to avoid Mesh Colliders, which are substantially more expensive than the primitive colliders.</span></span>

        Sphere < Capsule < Box <<< Mesh (Convex) < Mesh (non-Convex)

    <span data-ttu-id="1d0e8-196">Pour plus d’informations, consultez [meilleures pratiques pour la physique Unity](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices)</span><span class="sxs-lookup"><span data-stu-id="1d0e8-196">See [Unity Physics Best Practices](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices) for more info</span></span>

2) <span data-ttu-id="1d0e8-197">**Animations**</span><span class="sxs-lookup"><span data-stu-id="1d0e8-197">**Animations**</span></span>

    <span data-ttu-id="1d0e8-198">Désactivez les animations inactives en désactivant le composant d’animation (la désactivation de l’objet de jeu n’a pas le même effet).</span><span class="sxs-lookup"><span data-stu-id="1d0e8-198">Disable idle animations by disabling the Animator component (disabling the game object won't have the same effect).</span></span> <span data-ttu-id="1d0e8-199">Évitez les modèles de conception où un animateur se trouve dans une boucle qui affecte une valeur à la même chose.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-199">Avoid design patterns where an animator sits in a loop setting a value to the same thing.</span></span> <span data-ttu-id="1d0e8-200">Cette technique présente une surcharge considérable, sans effet sur l’application.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-200">There is considerable overhead for this technique, with no effect on the application.</span></span> [<span data-ttu-id="1d0e8-201">Pour en savoir plus, cliquez ici.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-201">Learn more here.</span></span>](https://docs.unity3d.com/Manual/MecanimPeformanceandOptimization.html)

3) <span data-ttu-id="1d0e8-202">**Algorithmes complexes**</span><span class="sxs-lookup"><span data-stu-id="1d0e8-202">**Complex algorithms**</span></span>

    <span data-ttu-id="1d0e8-203">Si votre application utilise des algorithmes complexes tels que des cinématiques inverses, des recherches de chemin, etc., recherchez une approche plus simple ou ajustez les paramètres pertinents pour leurs performances.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-203">If your application is using complex algorithms such as inverse kinematics, path finding, etc, look to find a simpler approach or adjust relevant settings for their performance</span></span>

## <a name="cpu-to-gpu-performance-recommendations"></a><span data-ttu-id="1d0e8-204">Recommandations relatives aux performances de l’UC vers GPU</span><span class="sxs-lookup"><span data-stu-id="1d0e8-204">CPU-to-GPU performance recommendations</span></span>

<span data-ttu-id="1d0e8-205">En règle générale, les performances de l’UC vers le GPU baissent les **appels de dessin** soumis à la carte graphique.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-205">Generally, CPU-to-GPU performance comes down to the **draw calls** submitted to the graphics card.</span></span> <span data-ttu-id="1d0e8-206">Pour améliorer les performances, les appels de dessin doivent être stratégiques, **réduits** ou **b) restructurés** pour obtenir des résultats optimaux.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-206">To improve performance, draw calls need to be strategically **a) reduced** or **b) restructured** for optimal results.</span></span> <span data-ttu-id="1d0e8-207">Étant donné que les appels de dessin eux-mêmes sont gourmands en ressources, leur réduction réduira le travail global requis.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-207">Since draw calls themselves are resource-intensive, reducing them will reduce overall work required.</span></span> <span data-ttu-id="1d0e8-208">En outre, les changements d’État entre les appels de dessin nécessitent une validation et des étapes de traduction coûteuses dans le pilote graphique et, par conséquent, la restructuration des appels de dessin de votre application pour limiter les changements d’État (c.-à-d.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-208">Further, state changes between draw calls requires costly validation and translation steps in the graphics driver and thus, restructuring of your application's draw calls to limit state changes (i.e</span></span> <span data-ttu-id="1d0e8-209">les différents matériaux, etc.) peuvent améliorer les performances.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-209">different materials, etc) can boost performance.</span></span>

<span data-ttu-id="1d0e8-210">Unity est un excellent article qui donne une vue d’ensemble et explore le traitement par lot des appels de dessin pour sa plateforme.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-210">Unity has a great article that gives an overview and dives into batching draw calls for their platform.</span></span>
- [<span data-ttu-id="1d0e8-211">Traitement par lot des appels Unity</span><span class="sxs-lookup"><span data-stu-id="1d0e8-211">Unity Draw Call Batching</span></span>](https://docs.unity3d.com/Manual/DrawCallBatching.html)

#### <a name="single-pass-instanced-rendering"></a><span data-ttu-id="1d0e8-212">Rendu d’instance à passe unique</span><span class="sxs-lookup"><span data-stu-id="1d0e8-212">Single pass instanced rendering</span></span>

<span data-ttu-id="1d0e8-213">Le rendu d’instance à passage unique dans Unity permet de réduire les appels de dessin pour chaque œil jusqu’à un appel de dessin instancié.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-213">Single Pass Instanced Rendering in Unity allows for draw calls for each eye to be reduced down to one instanced draw call.</span></span> <span data-ttu-id="1d0e8-214">En raison de la cohérence du cache entre deux appels de dessin, il y a également une amélioration des performances sur le GPU.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-214">Due to cache coherency between two draw calls, there is also some performance improvement on the GPU as well.</span></span>

<span data-ttu-id="1d0e8-215">Pour activer cette fonctionnalité dans votre projet Unity</span><span class="sxs-lookup"><span data-stu-id="1d0e8-215">To enable this feature in your Unity Project</span></span>
1)  <span data-ttu-id="1d0e8-216">Ouvrez **les paramètres du XR Player** (accédez à **modifier** > **paramètres du projet** > **lecteur** > **paramètres XR**)</span><span class="sxs-lookup"><span data-stu-id="1d0e8-216">Open **Player XR Settings** (go to **Edit** > **Project Settings** > **Player** > **XR Settings**)</span></span>
2) <span data-ttu-id="1d0e8-217">Sélectionnez **une instance de passe unique** dans le menu déroulant **méthode de rendu stéréo** (la case à cocher de**la réalité virtuelle** doit être activée)</span><span class="sxs-lookup"><span data-stu-id="1d0e8-217">Select **Single Pass Instanced** from the **Stereo Rendering Method** drop-down menu (**Virtual Reality Supported** checkbox must be checked)</span></span>

<span data-ttu-id="1d0e8-218">Lisez les articles suivants sur Unity pour plus d’informations sur cette approche de rendu.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-218">Read the following articles from Unity for details with this rendering approach.</span></span>
- [<span data-ttu-id="1d0e8-219">Optimisation des performances de l’AR et du VR avec un rendu stéréo avancé</span><span class="sxs-lookup"><span data-stu-id="1d0e8-219">How to maximize AR and VR performance with advanced stereo rendering</span></span>](https://blogs.unity3d.com/2017/11/21/how-to-maximize-ar-and-vr-performance-with-advanced-stereo-rendering/)
- [<span data-ttu-id="1d0e8-220">Instanciation à passage unique</span><span class="sxs-lookup"><span data-stu-id="1d0e8-220">Single Pass Instancing</span></span>](https://docs.unity3d.com/Manual/SinglePassInstancing.html) 

>[!NOTE]
> <span data-ttu-id="1d0e8-221">Un problème courant avec un rendu d’instance à passage unique se produit si les développeurs possèdent déjà des nuanceurs personnalisés existants non écrits pour l’instanciation.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-221">One common issue with Single Pass Instanced Rendering occurs if developers already have existing custom shaders not written for instancing.</span></span> <span data-ttu-id="1d0e8-222">Une fois cette fonctionnalité activée, les développeurs peuvent remarquer que certains GameObjects ne s’affichent qu’en un seul œil.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-222">After enabling this feature, developers may notice some GameObjects only render in one eye.</span></span> <span data-ttu-id="1d0e8-223">Cela est dû au fait que les nuanceurs personnalisés associés n’ont pas les propriétés appropriées pour l’instanciation.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-223">This is because the associated custom shaders do not have the appropriate properties for instancing.</span></span>
>
> <span data-ttu-id="1d0e8-224">Consultez [rendu stéréo à passage unique pour HoloLens](https://docs.unity3d.com/Manual/SinglePassStereoRenderingHoloLens.html) à partir d’Unity pour savoir comment résoudre ce problème</span><span class="sxs-lookup"><span data-stu-id="1d0e8-224">See [Single Pass Stereo Rendering for HoloLens](https://docs.unity3d.com/Manual/SinglePassStereoRenderingHoloLens.html) from Unity for how to address this problem</span></span>

#### <a name="static-batching"></a><span data-ttu-id="1d0e8-225">Traitement par lot statique</span><span class="sxs-lookup"><span data-stu-id="1d0e8-225">Static batching</span></span>

<span data-ttu-id="1d0e8-226">Unity peut traiter par lot de nombreux objets statiques pour réduire les appels de dessin au GPU.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-226">Unity is able to batch many static objects to reduce draw calls to the GPU.</span></span> <span data-ttu-id="1d0e8-227">Le traitement par lots statique fonctionne pour la plupart des objets de [convertisseur](https://docs.unity3d.com/ScriptReference/Renderer.html) dans Unity qui **1) partagent le même matériau** et **2) sont tous marqués comme *statiques***  (sélectionnez un objet dans Unity et cliquez sur la case à cocher en haut à droite de l’inspecteur).</span><span class="sxs-lookup"><span data-stu-id="1d0e8-227">Static Batching works for most [Renderer](https://docs.unity3d.com/ScriptReference/Renderer.html) objects in Unity that **1) share the same material** and **2) are all marked as *Static*** (Select an object in Unity and click the checkbox in the top right of the inspector).</span></span> <span data-ttu-id="1d0e8-228">Les GameObjects marqués comme *static* ne peuvent pas être déplacés tout au long de l’exécution de votre application.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-228">GameObjects marked as *Static* cannot be moved throughout your application's runtime.</span></span> <span data-ttu-id="1d0e8-229">Par conséquent, le traitement par lot statique peut être difficile à exploiter sur HoloLens, où pratiquement tous les objets doivent être placés, déplacés, mis à l’échelle, etc. Pour les casques immersifs, le traitement par lot statique peut réduire considérablement les appels de dessin et donc améliorer les performances.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-229">Thus, static batching can be difficult to leverage on HoloLens where virtually every object needs to be placed, moved, scaled, etc. For immersive headsets, static batching can dramatically reduce draw calls and thus improve performance.</span></span>

<span data-ttu-id="1d0e8-230">Pour plus d’informations, consultez *traitement par lot statique* sous [créer un traitement par lot dans Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) .</span><span class="sxs-lookup"><span data-stu-id="1d0e8-230">Read *Static Batching* under [Draw Call Batching in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) for more details.</span></span>

#### <a name="dynamic-batching"></a><span data-ttu-id="1d0e8-231">Traitement par lot dynamique</span><span class="sxs-lookup"><span data-stu-id="1d0e8-231">Dynamic batching</span></span>

<span data-ttu-id="1d0e8-232">Étant donné qu’il est difficile de marquer les objets comme *statiques* pour le développement HoloLens, le traitement par lot dynamique peut être un excellent outil pour compenser cette fonctionnalité non compensée.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-232">Since it is problematic to mark objects as *Static* for HoloLens development, dynamic batching can be a great tool to compensate for this lacking feature.</span></span> <span data-ttu-id="1d0e8-233">Bien entendu, il peut également être utile sur les casques immersifs.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-233">Of course, it can also be useful on immersive headsets, as well.</span></span> <span data-ttu-id="1d0e8-234">Toutefois, le traitement dynamique dans Unity peut être difficile à activer, car GameObjects doit **partager les mêmes documents** et **b) répondre à une longue liste d’autres critères**.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-234">However, dynamic batching in Unity can be difficult to enable because GameObjects must **a) share the same Material** and **b) meet a long list of other criteria**.</span></span>

<span data-ttu-id="1d0e8-235">Pour obtenir la liste complète, lisez *traitement dynamique par lot* sous l' [appel de dessin](https://docs.unity3d.com/Manual/DrawCallBatching.html) .</span><span class="sxs-lookup"><span data-stu-id="1d0e8-235">Read *Dynamic Batching* under [Draw Call Batching in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) for the full list.</span></span> <span data-ttu-id="1d0e8-236">En règle générale, les GameObjects ne sont plus valides pour être regroupés de manière dynamique, car les données de maillage associées ne peuvent pas dépasser 300 sommets.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-236">Most commonly, GameObjects become invalid to be batched dynamically, because the associated mesh data can be no more than 300 vertices.</span></span>

#### <a name="other-techniques"></a><span data-ttu-id="1d0e8-237">Autres techniques</span><span class="sxs-lookup"><span data-stu-id="1d0e8-237">Other techniques</span></span>

<span data-ttu-id="1d0e8-238">Le traitement par lot ne peut se produire que si plusieurs GameObjects sont en mesure de partager le même document.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-238">Batching can only occur if multiple GameObjects are able to share the same material.</span></span> <span data-ttu-id="1d0e8-239">En règle générale, cette opération est bloquée par la nécessité pour GameObjects d’avoir une texture unique pour leur matériau respectif.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-239">Typically, this will be blocked by the need for GameObjects to have a unique texture for their respective Material.</span></span> <span data-ttu-id="1d0e8-240">Il est courant de combiner les textures en une seule grande texture, une méthode appelée « [Atlas des textures](https://en.wikipedia.org/wiki/Texture_atlas)».</span><span class="sxs-lookup"><span data-stu-id="1d0e8-240">It is common to combine Textures into one big Texture, a method known as [Texture Atlasing](https://en.wikipedia.org/wiki/Texture_atlas).</span></span>

<span data-ttu-id="1d0e8-241">En outre, il est généralement préférable de combiner les mailles en un seul GameObject, lorsque cela est possible et raisonnable.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-241">Furthermore, it is generally preferable to combine meshes into one GameObject where possible and reasonable.</span></span> <span data-ttu-id="1d0e8-242">Chaque convertisseur d’Unity a ses appels de dessin associés et envoie un maillage combiné sous un convertisseur.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-242">Each Renderer in Unity will have its associated draw call(s) versus submitting a combined mesh under one Renderer.</span></span>

>[!NOTE]
> <span data-ttu-id="1d0e8-243">Modification des propriétés du convertisseur. la documentation au moment de l’exécution crée une copie du matériau et, par conséquent, interrompt le traitement par lot.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-243">Modifying properties of Renderer.material at runtime will create a copy of the Material and thus potentially break batching.</span></span> <span data-ttu-id="1d0e8-244">Utilisez Renderr. sharedMaterial pour modifier les propriétés des matériaux partagés entre les GameObjects.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-244">Use Renderer.sharedMaterial to modify shared material properties across GameObjects.</span></span>

## <a name="gpu-performance-recommendations"></a><span data-ttu-id="1d0e8-245">Recommandations relatives aux performances GPU</span><span class="sxs-lookup"><span data-stu-id="1d0e8-245">GPU performance recommendations</span></span>

<span data-ttu-id="1d0e8-246">En savoir plus sur [l’optimisation du rendu graphique dans Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games)</span><span class="sxs-lookup"><span data-stu-id="1d0e8-246">Learn more about [optimizing graphics rendering in Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games)</span></span>

### <a name="optimize-depth-buffer-sharing"></a><span data-ttu-id="1d0e8-247">Optimiser le partage du tampon de profondeur</span><span class="sxs-lookup"><span data-stu-id="1d0e8-247">Optimize depth buffer sharing</span></span>

<span data-ttu-id="1d0e8-248">Il est généralement recommandé d’activer le **partage de mémoire tampon de profondeur** sous les paramètres de **XR Player** pour optimiser la stabilité de l' [hologramme](Hologram-stability.md).</span><span class="sxs-lookup"><span data-stu-id="1d0e8-248">It is generally recommended to enable **Depth buffer sharing** under **Player XR Settings** to optimize for [hologram stability](Hologram-stability.md).</span></span> <span data-ttu-id="1d0e8-249">Lors de l’activation de la reprojection à l’étape à base de la profondeur avec ce paramètre, il est recommandé de sélectionner le **format de profondeur 16** bits au lieu du **format de profondeur 24 bits**.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-249">When enabling depth-based late-stage reprojection with this setting however, it is recommended to select **16-bit depth format** instead of **24-bit depth format**.</span></span> <span data-ttu-id="1d0e8-250">Les mémoires tampons de profondeur 16 bits réduisent considérablement la bande passante (et donc la puissance) associée au trafic de mémoire tampon de profondeur.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-250">The 16-bit depth buffers will drastically reduce the bandwidth (and thus power) associated with depth buffer traffic.</span></span> <span data-ttu-id="1d0e8-251">Il peut s’agir d’un grand succès en matière de réduction de l’alimentation et d’amélioration des performances.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-251">This can be a big win both in power reduction and performance improvement.</span></span> <span data-ttu-id="1d0e8-252">Toutefois, il existe deux résultats négatifs possibles en utilisant *le format de profondeur 16 bits*.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-252">However, there are two possible negative outcomes by using *16-bit depth format*.</span></span>

<span data-ttu-id="1d0e8-253">**Z-combat**</span><span class="sxs-lookup"><span data-stu-id="1d0e8-253">**Z-Fighting**</span></span>

<span data-ttu-id="1d0e8-254">La fidélité de la plage de profondeur réduite rend la [lutte z](https://en.wikipedia.org/wiki/Z-fighting) plus susceptible de se produire avec 16 bits que 24 bits.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-254">The reduced depth range fidelity makes [z-fighting](https://en.wikipedia.org/wiki/Z-fighting) more likely to occur with 16-bit than 24-bit.</span></span> <span data-ttu-id="1d0e8-255">Pour éviter ces artefacts, modifiez les plans de clip proches/Far de l' [appareil photo Unity](https://docs.unity3d.com/Manual/class-Camera.html) afin de réduire la précision.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-255">To avoid these artifacts, modify the near/far clip planes of the [Unity camera](https://docs.unity3d.com/Manual/class-Camera.html) to account for the lower precision.</span></span> <span data-ttu-id="1d0e8-256">Pour les applications basées sur HoloLens, un plan de découpage de 50 millions à la place de l’unité par défaut de l’unité de mesure peut généralement éliminer toute lutte z.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-256">For HoloLens-based applications, a far clip plane of 50m instead of the Unity default 1000m can generally eliminate any z-fighting.</span></span>

<span data-ttu-id="1d0e8-257">**Tampon de stencil désactivé**</span><span class="sxs-lookup"><span data-stu-id="1d0e8-257">**Disabled Stencil Buffer**</span></span>

<span data-ttu-id="1d0e8-258">Quand Unity crée une [texture de rendu avec une profondeur de 16 bits](https://docs.unity3d.com/ScriptReference/RenderTexture-depth.html), aucune mémoire tampon de stencil n’est créée.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-258">When Unity creates a [Render Texture with 16-bit depth](https://docs.unity3d.com/ScriptReference/RenderTexture-depth.html), there is no stencil buffer created.</span></span> <span data-ttu-id="1d0e8-259">La sélection du format de profondeur de 24 bits, par documentation Unity, créera une mémoire tampon z de 24 bits, ainsi qu’un [tampon de stencil de 8 bits] (https://docs.unity3d.com/Manual/SL-Stencil.html) (si 32 bits est applicable sur un appareil, ce qui est généralement le cas, par exemple, HoloLens).</span><span class="sxs-lookup"><span data-stu-id="1d0e8-259">Selecting 24-bit depth format, per Unity documentation, will create a 24-bit z-buffer, as well as an [8-bit stencil buffer] (https://docs.unity3d.com/Manual/SL-Stencil.html) (if 32-bit is applicable on a device, which is generally the case such as HoloLens).</span></span>

### <a name="avoid-full-screen-effects"></a><span data-ttu-id="1d0e8-260">Éviter les effets plein écran</span><span class="sxs-lookup"><span data-stu-id="1d0e8-260">Avoid full-screen effects</span></span>

<span data-ttu-id="1d0e8-261">Les techniques qui fonctionnent en mode plein écran peuvent être assez onéreuses, car leur ordre de grandeur est de millions d’opérations chaque trame.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-261">Techniques that operate on the full screen can be quite expensive since their order of magnitude is millions of operations every frame.</span></span> <span data-ttu-id="1d0e8-262">Par conséquent, il est recommandé d’éviter les effets de la [publication](https://docs.unity3d.com/Manual/PostProcessingOverview.html) , tels que l’anticrénelage, les fleurs et bien plus encore.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-262">Thus, it is recommended to avoid [post-processing effects](https://docs.unity3d.com/Manual/PostProcessingOverview.html) such as anti-aliasing, bloom, and more.</span></span>

### <a name="optimal-lighting-settings"></a><span data-ttu-id="1d0e8-263">Paramètres d’éclairage optimaux</span><span class="sxs-lookup"><span data-stu-id="1d0e8-263">Optimal lighting settings</span></span>

<span data-ttu-id="1d0e8-264">L' [éclairage global](https://docs.unity3d.com/Manual/GIIntro.html) en temps réel dans Unity peut fournir des résultats visuels remarquables, mais implique des calculs d’éclairage très coûteux.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-264">[Real-time Global Illumination](https://docs.unity3d.com/Manual/GIIntro.html) in Unity can provide outstanding visual results but involves quite expensive lighting calculations.</span></span> <span data-ttu-id="1d0e8-265">Il est recommandé de désactiver l’éclairage global en temps réel pour chaque fichier de scène Unity via la **fenêtre** > le **rendu** > **paramètres d’éclairage** > de décocher l' **éclairage global en temps réel**.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-265">It is recommended to disable Realtime Global Illumination for every Unity scene file via **Window** > **Rendering** > **Lighting Settings** > Uncheck **Real-time Global Illumination**.</span></span>

<span data-ttu-id="1d0e8-266">En outre, il est recommandé de désactiver tous les casts instantanés, car ils ajoutent également des passes GPU coûteuses à une scène Unity.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-266">Furthermore, it is recommended to disable all shadow casting as these also add expensive GPU passes onto a Unity scene.</span></span> <span data-ttu-id="1d0e8-267">Les ombres peuvent être désactivées par lumière, mais peuvent également être contrôlées de façon holistique via des paramètres de qualité.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-267">Shadows can be disable per light but can also be controlled holistically via Quality settings.</span></span>

<span data-ttu-id="1d0e8-268">**Modifiez** > **paramètres du projet**, puis sélectionnez la catégorie **qualité** > sélectionnez **faible qualité** pour la plateforme UWP.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-268">**Edit** > **Project Settings**, then select the **Quality** category > Select **Low Quality** for the UWP Platform.</span></span> <span data-ttu-id="1d0e8-269">Il est également possible de définir simplement la propriété **Shadows** pour **Désactiver les ombres**.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-269">One can also just set the **Shadows** property to **Disable Shadows**.</span></span>

### <a name="reduce-poly-count"></a><span data-ttu-id="1d0e8-270">Réduire le nombre de poly</span><span class="sxs-lookup"><span data-stu-id="1d0e8-270">Reduce poly count</span></span>

<span data-ttu-id="1d0e8-271">Le nombre de polygones est généralement réduit par</span><span class="sxs-lookup"><span data-stu-id="1d0e8-271">Polygon count is usually reduced by either</span></span>
1) <span data-ttu-id="1d0e8-272">Suppression d’objets d’une scène</span><span class="sxs-lookup"><span data-stu-id="1d0e8-272">Removing objects from a scene</span></span>
2) <span data-ttu-id="1d0e8-273">Décimalisation de la ressource qui réduit le nombre de polygones pour un filet donné</span><span class="sxs-lookup"><span data-stu-id="1d0e8-273">Asset decimation which reduces the number of polygons for a given mesh</span></span>
3) <span data-ttu-id="1d0e8-274">Implémentation d’un [système de niveau de détail (LOD)](https://docs.unity3d.com/Manual/LevelOfDetail.html) dans votre application qui restitue des objets éloignés avec une version de polygone plus faible de la même géométrie</span><span class="sxs-lookup"><span data-stu-id="1d0e8-274">Implementing a [Level of Detail (LOD) System](https://docs.unity3d.com/Manual/LevelOfDetail.html) into your application which renders far away objects with lower-polygon version of the same geometry</span></span>

### <a name="understanding-shaders-in-unity"></a><span data-ttu-id="1d0e8-275">Fonctionnement des nuanceurs dans Unity</span><span class="sxs-lookup"><span data-stu-id="1d0e8-275">Understanding shaders in Unity</span></span>

<span data-ttu-id="1d0e8-276">Une approximation facile pour comparer les nuanceurs en matière de performances consiste à identifier le nombre moyen d’opérations qui s’exécutent chaque fois au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-276">An easy approximation to compare shaders in performance is to identify the average number of operations each executes at runtime.</span></span> <span data-ttu-id="1d0e8-277">Cela peut être fait facilement dans Unity.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-277">This can be done easily in Unity.</span></span>

1) <span data-ttu-id="1d0e8-278">Sélectionnez votre élément de nuanceur ou sélectionnez un matériau, puis dans le coin supérieur droit de la fenêtre de l’inspecteur, sélectionnez l’icône d’engrenage, puis sélectionnez le **nuanceur** .</span><span class="sxs-lookup"><span data-stu-id="1d0e8-278">Select your shader asset or select a material, then in the top right corner of the inspector window, select the gear icon followed by **"Select Shader"**</span></span>

    ![Sélectionner le nuanceur dans Unity](images/Select-shader-unity.png)
2) <span data-ttu-id="1d0e8-280">Une fois l’élément de nuanceur sélectionné, cliquez sur le bouton **« compiler et afficher le code »** sous la fenêtre de l’inspecteur.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-280">With the shader asset selected, click the **"Compile and show code"** button under the inspector window</span></span>

    ![Compiler le code du nuanceur dans Unity](images/compile-shader-code-unity.PNG)

3) <span data-ttu-id="1d0e8-282">Après la compilation, recherchez la section des statistiques dans les résultats avec le nombre d’opérations différentes pour le vertex shader et le nuanceur de pixels (Remarque : les nuanceurs de pixels sont souvent également appelés nuanceurs de fragments)</span><span class="sxs-lookup"><span data-stu-id="1d0e8-282">After compiling, look for the statistics section in the results with the number of different operations for both the vertex and pixel shader (Note: pixel shaders are often also called fragment shaders)</span></span>

    ![Opérations de nuanceur standard Unity](images/unity-standard-shader-compilation.png)

#### <a name="optimize-pixel-shaders"></a><span data-ttu-id="1d0e8-284">Optimiser les nuanceurs de pixels</span><span class="sxs-lookup"><span data-stu-id="1d0e8-284">Optimize pixel shaders</span></span>

<span data-ttu-id="1d0e8-285">En examinant les résultats des statistiques compilées à l’aide de la méthode ci-dessus, le [nuanceur de fragments](https://en.wikipedia.org/wiki/Shader#Pixel_shaders) exécute généralement plus d’opérations que le [nuanceur de sommets](https://en.wikipedia.org/wiki/Shader#Vertex_shaders), en moyenne.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-285">Looking at the compiled statistic results using the method above, the [fragment shader](https://en.wikipedia.org/wiki/Shader#Pixel_shaders) will generally execute more operations than the [vertex shader](https://en.wikipedia.org/wiki/Shader#Vertex_shaders), on average.</span></span> <span data-ttu-id="1d0e8-286">Le nuanceur de fragments, également connu sous le nom de nuanceur de pixels, est exécuté par pixel sur la sortie de l’écran, tandis que le nuanceur de sommets est exécuté uniquement par sommet de tous les maillages dessinés à l’écran.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-286">The fragment shader, also known as the pixel shader, is executed per pixel on the screen output while the vertex shader is only executed per-vertex of all meshes being drawn to the screen.</span></span> 

<span data-ttu-id="1d0e8-287">Par conséquent, les nuanceurs de fragments ont plus d’instructions que les nuanceurs vertex en raison de tous les calculs d’éclairage, les nuanceurs de fragments sont presque toujours exécutés sur un jeu de données plus volumineux.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-287">Thus, not only do fragment shaders have more instructions than vertex shaders because of all the lighting calculations, fragment shaders are almost always executed on a larger dataset.</span></span> <span data-ttu-id="1d0e8-288">Par exemple, si la sortie d’écran est une image de 2k Ko, le nuanceur de fragments peut être exécuté 2000 \* 2000 = 4 millions fois.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-288">For example, if the screen output is a 2k by 2k image, then the fragment shader can get executed 2,000\*2,000 = 4,000,000 times.</span></span> <span data-ttu-id="1d0e8-289">En cas de rendu de deux yeux, ce nombre est doublé puisqu’il y a deux écrans.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-289">If rendering two eyes, this number doubles since there are two screens.</span></span> <span data-ttu-id="1d0e8-290">Si une application de réalité mixte a plusieurs passes, des effets de la publication plein écran ou un rendu de plusieurs mailles sur le même pixel, ce nombre augmente considérablement.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-290">If a mixed reality application has multiple passes, full-screen post-processing effects, or rendering multiple meshes to the same pixel, this number will increase dramatically.</span></span> 

<span data-ttu-id="1d0e8-291">Par conséquent, la réduction du nombre d’opérations dans le nuanceur de fragments peut entraîner des gains de performances bien supérieurs par rapport aux optimisations dans le nuanceur de sommets.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-291">Therefore, reducing the number of operations in the fragment shader can generally give far greater performance gains over optimizations in the vertex shader.</span></span>

#### <a name="unity-standard-shader-alternatives"></a><span data-ttu-id="1d0e8-292">Alternatives de nuanceur standard Unity</span><span class="sxs-lookup"><span data-stu-id="1d0e8-292">Unity Standard shader alternatives</span></span>

<span data-ttu-id="1d0e8-293">Au lieu d’utiliser un rendu physique (PBR) ou un autre nuanceur de haute qualité, examinez l’utilisation d’un nuanceur plus performant et moins onéreux.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-293">Instead of using a physically based rendering (PBR) or another high-quality shader, look at utilizing a more performant and cheaper shader.</span></span> <span data-ttu-id="1d0e8-294">La [boîte à outils de réalité mixte](https://github.com/Microsoft/MixedRealityToolkit-Unity) fournit le [nuanceur standard MRTK](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/README_MRTKStandardShader.html) qui a été optimisé pour les projets de réalité mixte.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-294">The [Mixed Reality Toolkit](https://github.com/Microsoft/MixedRealityToolkit-Unity) provides the [MRTK standard shader](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/README_MRTKStandardShader.html) that has been optimized for mixed reality projects.</span></span>

<span data-ttu-id="1d0e8-295">Unity fournit également un non éclairé, un sommet éclairé, une diffusion et d’autres options de nuanceur simplifiées qui sont nettement plus rapides par rapport au nuanceur standard Unity.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-295">Unity also provides an unlit, vertex lit, diffuse, and other simplified shader options that are significantly faster compared to the Unity Standard shader.</span></span> <span data-ttu-id="1d0e8-296">Pour plus d’informations, consultez [utilisation et performances des nuanceurs intégrés](https://docs.unity3d.com/Manual/shader-Performance.html) .</span><span class="sxs-lookup"><span data-stu-id="1d0e8-296">See [Usage and Performance of Built-in Shaders](https://docs.unity3d.com/Manual/shader-Performance.html) for more detailed information.</span></span>

#### <a name="shader-preloading"></a><span data-ttu-id="1d0e8-297">Préchargement de nuanceur</span><span class="sxs-lookup"><span data-stu-id="1d0e8-297">Shader preloading</span></span>

<span data-ttu-id="1d0e8-298">Utilisez le *préchargement des nuanceurs* et d’autres astuces pour optimiser le [temps de chargement des nuanceurs](https://docs.unity3d.com/Manual/OptimizingShaderLoadTime.html).</span><span class="sxs-lookup"><span data-stu-id="1d0e8-298">Use *Shader preloading* and other tricks to optimize [shader load time](https://docs.unity3d.com/Manual/OptimizingShaderLoadTime.html).</span></span> <span data-ttu-id="1d0e8-299">En particulier, le préchargement des nuanceurs signifie que vous ne verrez aucun crochet en raison de la compilation du nuanceur d’exécution.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-299">In particular, shader preloading means you won't see any hitches due to runtime shader compilation.</span></span>

### <a name="limit-overdraw"></a><span data-ttu-id="1d0e8-300">Limiter le surdessin</span><span class="sxs-lookup"><span data-stu-id="1d0e8-300">Limit overdraw</span></span>

<span data-ttu-id="1d0e8-301">Dans Unity, vous pouvez afficher le surdessin pour leur scène, en basculant sur le [**menu mode dessin**](https://docs.unity3d.com/Manual/ViewModes.html) dans l’angle supérieur gauche de la **vue scène** et en sélectionnant **surdraw**.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-301">In Unity, one can display overdraw for their scene, by toggling the [**draw mode menu**](https://docs.unity3d.com/Manual/ViewModes.html) in the top-left corner of the **Scene view** and selecting **Overdraw**.</span></span>

<span data-ttu-id="1d0e8-302">En règle générale, le surdessin peut être atténué en éliminant les objets à l’avance avant leur envoi au GPU.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-302">Generally, overdraw can be mitigated by culling objects ahead of time before they are sent to the GPU.</span></span> <span data-ttu-id="1d0e8-303">Unity fournit des détails sur l’implémentation de l' [élimination des occlusions](https://docs.unity3d.com/Manual/OcclusionCulling.html) pour son moteur.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-303">Unity provides details on implementing [Occlusion Culling](https://docs.unity3d.com/Manual/OcclusionCulling.html) for their engine.</span></span>

## <a name="memory-recommendations"></a><span data-ttu-id="1d0e8-304">Recommandations de mémoire</span><span class="sxs-lookup"><span data-stu-id="1d0e8-304">Memory recommendations</span></span>

<span data-ttu-id="1d0e8-305">L’allocation de mémoire excessive & les opérations de désallocation peuvent avoir des effets négatifs sur votre application holographique, ce qui entraîne des performances incohérentes, des trames figées et d’autres comportements nuisibles.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-305">Excessive memory allocation & deallocation operations can have adverse effects on your holographic application, resulting in inconsistent performance, frozen frames, and other detrimental behavior.</span></span> <span data-ttu-id="1d0e8-306">Il est particulièrement important de comprendre les considérations relatives à la mémoire lors du développement dans Unity, car la gestion de la mémoire est contrôlée par le garbage collector.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-306">It is especially important to understand memory considerations when developing in Unity since memory management is controlled by the garbage collector.</span></span>

#### <a name="garbage-collection"></a><span data-ttu-id="1d0e8-307">Garbage collection</span><span class="sxs-lookup"><span data-stu-id="1d0e8-307">Garbage collection</span></span>

<span data-ttu-id="1d0e8-308">Les applications holographiques perdront le traitement du temps de calcul au garbage collector (GC) quand le GC est activé pour analyser les objets qui ne sont plus dans la portée pendant l’exécution et où leur mémoire doit être libérée, de sorte qu’elle peut être mise à disposition en vue d’une réutilisation.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-308">Holographic apps will lose processing compute time to the garbage collector (GC) when the GC is activated to analyze objects that are no longer in scope during execution and their memory needs to be released, so it can be made available for re-use.</span></span> <span data-ttu-id="1d0e8-309">Les allocations constantes et les désallocations requièrent généralement que le garbage collector s’exécute plus fréquemment, ce qui nuit aux performances et à l’expérience de l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-309">Constant allocations and de-allocations will generally require the garbage collector to run more frequently, thus hurting performance and user experience.</span></span>

<span data-ttu-id="1d0e8-310">Unity a fourni une excellente page qui explique en détail comment le garbage collector fonctionne et des conseils pour écrire du code plus efficace en ce qui concerne la gestion de la mémoire.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-310">Unity has provided an excellent page that explains in detail how the garbage collector works and tips to write more efficient code in regards to memory management.</span></span>
- [<span data-ttu-id="1d0e8-311">Optimisation des garbage collection dans les jeux Unity</span><span class="sxs-lookup"><span data-stu-id="1d0e8-311">Optimizing garbage collection in Unity games</span></span>](https://unity3d.com/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069)

<span data-ttu-id="1d0e8-312">L’une des pratiques les plus courantes qui conduisent à une garbage collection excessive ne consiste pas à mettre en cache des références à des composants et des classes dans le développement Unity.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-312">One of the most common practices that leads to excessive garbage collection is not caching references to components and classes in Unity development.</span></span> <span data-ttu-id="1d0e8-313">Toutes les références doivent être capturées pendant Start () ou éveillé () et réutilisées dans des fonctions ultérieures telles que Update () ou LateUpdate ().</span><span class="sxs-lookup"><span data-stu-id="1d0e8-313">Any references should be captured during Start() or Awake() and re-used in later functions such as Update() or LateUpdate().</span></span>

<span data-ttu-id="1d0e8-314">Autres conseils rapides :</span><span class="sxs-lookup"><span data-stu-id="1d0e8-314">Other quick tips:</span></span>
- <span data-ttu-id="1d0e8-315">Utiliser la classe [StringBuilder](https://docs.microsoft.com/dotnet/api/system.text.stringbuilder?view=netframework-4.7.2) C# pour créer dynamiquement des chaînes complexes au moment de l’exécution</span><span class="sxs-lookup"><span data-stu-id="1d0e8-315">Use the [StringBuilder](https://docs.microsoft.com/dotnet/api/system.text.stringbuilder?view=netframework-4.7.2) C# class to dynamically build complex strings at runtime</span></span>
- <span data-ttu-id="1d0e8-316">Supprimer les appels à Debug. log () quand vous n’en avez plus besoin, car ils s’exécutent toujours dans toutes les versions de build d’une application</span><span class="sxs-lookup"><span data-stu-id="1d0e8-316">Remove calls to Debug.Log() when no longer needed, as they still execute in all build versions of an app</span></span>
- <span data-ttu-id="1d0e8-317">Si votre application holographique requiert généralement beaucoup de mémoire, envisagez d’appeler [ _**System. gc. Collect ()**_ ](https://docs.microsoft.com/dotnet/api/system.gc.collect?view=netframework-4.7.2) pendant les phases de chargement, par exemple lors de la présentation d’un écran de chargement ou de transition.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-317">If your holographic app generally requires lots of memory, consider calling  [_**System.GC.Collect()**_](https://docs.microsoft.com/dotnet/api/system.gc.collect?view=netframework-4.7.2) during loading phases such as when presenting a loading or transition screen</span></span>

#### <a name="object-pooling"></a><span data-ttu-id="1d0e8-318">Mise en pool d’objets</span><span class="sxs-lookup"><span data-stu-id="1d0e8-318">Object pooling</span></span>

<span data-ttu-id="1d0e8-319">Le mise en pool d’objets est une technique populaire pour réduire le coût des allocations continues & des désallocations d’objets.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-319">Object pooling is a popular technique to reduce the cost of continuous allocations & deallocations of objects.</span></span> <span data-ttu-id="1d0e8-320">Pour ce faire, vous devez allouer un grand pool d’objets identiques et réutiliser les instances inactives de ce pool au lieu de générer et de détruire constamment des objets dans le temps.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-320">This is done by allocating a large pool of identical objects and re-using inactive, available instances from this pool instead of constantly spawning and destroying objects over time.</span></span> <span data-ttu-id="1d0e8-321">Les pools d’objets sont idéaux pour les composants réutilisables qui ont une durée de vie variable pendant une application.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-321">Object pools are great for re-useable components that have variable lifetime during an app.</span></span>

- [<span data-ttu-id="1d0e8-322">Didacticiel de mise en pool d’objets dans Unity</span><span class="sxs-lookup"><span data-stu-id="1d0e8-322">Object Pooling Tutorial in Unity</span></span>](https://unity3d.com/learn/tutorials/topics/scripting/object-pooling) 

## <a name="startup-performance"></a><span data-ttu-id="1d0e8-323">Performances au démarrage</span><span class="sxs-lookup"><span data-stu-id="1d0e8-323">Startup performance</span></span>

<span data-ttu-id="1d0e8-324">Vous devez envisager de démarrer votre application avec une plus petite scène, puis d’utiliser *[SceneManager. LoadSceneAsync](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadSceneAsync.html)* pour charger le reste de la scène.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-324">You should consider starting your app with a smaller scene, then using *[SceneManager.LoadSceneAsync](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadSceneAsync.html)* to load the rest of the scene.</span></span> <span data-ttu-id="1d0e8-325">Cela permet à votre application d’accéder à un État interactif aussi rapide que possible.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-325">This allows your app to get to an interactive state as fast as possible.</span></span> <span data-ttu-id="1d0e8-326">N’oubliez pas qu’il peut y avoir un pic d’UC important pendant l’activation de la nouvelle scène et que tout contenu rendu peut être saccadé ou déposé.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-326">Be aware that there may be a large CPU spike while the new scene is being activated and that any rendered content might stutter or hitch.</span></span> <span data-ttu-id="1d0e8-327">Pour contourner ce cas, vous pouvez définir la propriété AsyncOperation. allowSceneActivation sur « false » sur la scène en cours de chargement, attendre le chargement de la scène, désélectionner l’écran en noir, puis rétablir la valeur « true » pour terminer l’activation de la scène.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-327">One way to work around this is to set the AsyncOperation.allowSceneActivation property to "false" on the scene being loaded, wait for the scene to load, clear the screen to black, and then set it back to "true" to complete the scene activation.</span></span>

<span data-ttu-id="1d0e8-328">N’oubliez pas que pendant le chargement de la scène de démarrage, l’écran de démarrage holographique s’affiche à l’attention de l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="1d0e8-328">Remember that while the startup scene is loading, the holographic splash screen will be displayed to the user.</span></span>

## <a name="see-also"></a><span data-ttu-id="1d0e8-329">Articles associés</span><span class="sxs-lookup"><span data-stu-id="1d0e8-329">See also</span></span>
- [<span data-ttu-id="1d0e8-330">Optimisation du rendu graphique dans les jeux Unity</span><span class="sxs-lookup"><span data-stu-id="1d0e8-330">Optimizing graphics rendering in Unity games</span></span>](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games?playlist=44069)
- [<span data-ttu-id="1d0e8-331">Optimisation des garbage collection dans les jeux Unity</span><span class="sxs-lookup"><span data-stu-id="1d0e8-331">Optimizing garbage collection in Unity games</span></span>](https://unity3d.com/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069)
- <span data-ttu-id="1d0e8-332">[Meilleures pratiques en matière de physique [Unity]](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices)</span><span class="sxs-lookup"><span data-stu-id="1d0e8-332">[Physics Best Practices [Unity]](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices)</span></span>
- <span data-ttu-id="1d0e8-333">[Optimisation des scripts [Unity]](https://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html)</span><span class="sxs-lookup"><span data-stu-id="1d0e8-333">[Optimizing Scripts [Unity]](https://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html)</span></span>
