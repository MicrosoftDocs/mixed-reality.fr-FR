---
title: Recommandations relatives aux performances pour Unity
description: Obtenir des conseils de Unity spécifiques pour améliorer les performances avec les applications de réalité mixte.
author: Troy-Ferrell
ms.author: trferrel
ms.date: 03/26/2019
ms.topic: article
keywords: graphiques, UC, gpu, de rendu, le garbage collection, hololens
ms.openlocfilehash: b0821f07184bff8630f6b6af0d0fc461f6fcd133
ms.sourcegitcommit: 8f3ff9738397d9b9fdf4703b14b89d416f0186a5
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 07/12/2019
ms.locfileid: "67843335"
---
# <a name="performance-recommendations-for-unity"></a><span data-ttu-id="2a504-104">Recommandations relatives aux performances pour Unity</span><span class="sxs-lookup"><span data-stu-id="2a504-104">Performance recommendations for Unity</span></span>

<span data-ttu-id="2a504-105">Cet article s’appuie sur la discussion décrite dans [recommandations relatives aux performances pour la réalité mixte](understanding-performance-for-mixed-reality.md) mais se concentre sur les apprentissages spécifiques à l’environnement du moteur Unity.</span><span class="sxs-lookup"><span data-stu-id="2a504-105">This article builds on the discussion outlined in [performance recommendations for mixed reality](understanding-performance-for-mixed-reality.md) but focuses on learnings specific to the Unity engine environment.</span></span>

<span data-ttu-id="2a504-106">Il est également vivement conseillé que les développeurs consulter le [environnement aux paramètres recommandés pour l’article Unity](Recommended-settings-for-unity.md).</span><span class="sxs-lookup"><span data-stu-id="2a504-106">It is also highly advisable that developers review the [recommended environment settings for Unity article](Recommended-settings-for-unity.md).</span></span> <span data-ttu-id="2a504-107">Cet article a contenu avec certaines configurations de scène plus importantes en ce qui concerne à la création d’applications de réalité mixte performante.</span><span class="sxs-lookup"><span data-stu-id="2a504-107">This article has content with some of the most important scene configurations in regards to building performant Mixed Reality apps.</span></span> <span data-ttu-id="2a504-108">Certains de ces paramètres recommandés sont également mis en surbrillance ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="2a504-108">Some of these recommended settings are highlighted below as well.</span></span>

## <a name="how-to-profile-with-unity"></a><span data-ttu-id="2a504-109">Comment Profiler avec Unity</span><span class="sxs-lookup"><span data-stu-id="2a504-109">How to profile with Unity</span></span>

<span data-ttu-id="2a504-110">Unity fournit le **[Unity Profiler](https://docs.unity3d.com/Manual/Profiler.html)** intégré qui est une excellente ressource pour rassembler des informations de performances précieuses pour votre application.</span><span class="sxs-lookup"><span data-stu-id="2a504-110">Unity provides the **[Unity Profiler](https://docs.unity3d.com/Manual/Profiler.html)** built-in which is a great resource to gather valuable performance insights for your particular app.</span></span> <span data-ttu-id="2a504-111">Bien que le profileur éditeur exécutable, ces mesures ne représentent pas l’environnement d’exécution true et par conséquent, les résultats à partir de ce doivent être utilisés avec précaution.</span><span class="sxs-lookup"><span data-stu-id="2a504-111">Although one can run the profiler in-editor, these metrics do not represent the true runtime environment and thus, results from this should be used cautiously.</span></span> <span data-ttu-id="2a504-112">Il est recommandé à profiler à distance à votre application pendant son exécution sur le périphérique pour des informations plus précises et exploitables.</span><span class="sxs-lookup"><span data-stu-id="2a504-112">It is recommended to remotely profile your application while running on device for most accurate and actionable insights.</span></span> <span data-ttu-id="2a504-113">En outre, d’Unity [Frame débogueur](https://docs.unity3d.com/Manual/FrameDebugger.html) est également très puissante et outil d’analyse à utiliser.</span><span class="sxs-lookup"><span data-stu-id="2a504-113">Further, Unity's [Frame Debugger](https://docs.unity3d.com/Manual/FrameDebugger.html)  is also a very powerful and insight tool to utilize.</span></span>

<span data-ttu-id="2a504-114">Unity fournit une documentation exceptionnelle pour :</span><span class="sxs-lookup"><span data-stu-id="2a504-114">Unity provides great documentation for:</span></span>
1) <span data-ttu-id="2a504-115">Comment connecter le [profileur Unity pour applications UWP à distance](https://docs.unity3d.com/Manual/windowsstore-profiler.html)</span><span class="sxs-lookup"><span data-stu-id="2a504-115">How to connect the [Unity profiler to UWP applications remotely](https://docs.unity3d.com/Manual/windowsstore-profiler.html)</span></span>
2) <span data-ttu-id="2a504-116">Comment efficacement [diagnostiquer les problèmes de performances avec le Profiler Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/diagnosing-performance-problems-using-profiler-window)</span><span class="sxs-lookup"><span data-stu-id="2a504-116">How to effectively [diagnose performance problems with the Unity Profiler](https://unity3d.com/learn/tutorials/temas/performance-optimization/diagnosing-performance-problems-using-profiler-window)</span></span>

>[!NOTE]
> <span data-ttu-id="2a504-117">Avec le Profiler Unity connecté et après avoir ajouté le profileur GPU (consultez *Profiler ajouter* dans le coin supérieur droit), vous pouvez voir combien de temps sur l’UC et GPU respectivement au milieu du profileur.</span><span class="sxs-lookup"><span data-stu-id="2a504-117">With the Unity Profiler connected and after adding the GPU profiler (see *Add Profiler* in top right corner), one can see how much time is being spent on the CPU & GPU respectively in the middle of the profiler.</span></span> <span data-ttu-id="2a504-118">Cela permet au développeur obtenir une approximation rapide si leur application est l’UC ou GPU délimité.</span><span class="sxs-lookup"><span data-stu-id="2a504-118">This allows the developer to get a quick approximation if their application is CPU or GPU bounded.</span></span>
>
> ![Plug-in unityvs processeur GPU](images/unity-profiler-cpu-gpu.png)

## <a name="cpu-performance-recommendations"></a><span data-ttu-id="2a504-120">Recommandations relatives aux performances de processeur</span><span class="sxs-lookup"><span data-stu-id="2a504-120">CPU performance recommendations</span></span>

<span data-ttu-id="2a504-121">Le contenu ci-dessous présente les plus pratiques de performances approfondies, particulièrement ciblés pour Unity & C# développement.</span><span class="sxs-lookup"><span data-stu-id="2a504-121">The content below covers more in-depth performance practices, especially targeted for Unity & C# development.</span></span>

#### <a name="cache-references"></a><span data-ttu-id="2a504-122">Références du cache</span><span class="sxs-lookup"><span data-stu-id="2a504-122">Cache references</span></span>

<span data-ttu-id="2a504-123">Il est recommandé de cache des références à tous les composants concernés et GameObjects lors de l’initialisation.</span><span class="sxs-lookup"><span data-stu-id="2a504-123">It is best practice to cache references to all relevant components and GameObjects at initialization.</span></span> <span data-ttu-id="2a504-124">Il s’agit, car la répétition des appels de fonction comme *[GetComponent\<T > ()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* nettement plus élevé par rapport à la mémoire pour stocker un pointeur de coût.</span><span class="sxs-lookup"><span data-stu-id="2a504-124">This is because repeating function calls such as *[GetComponent\<T>()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* are significantly more expensive relative to the memory cost to store a pointer.</span></span> <span data-ttu-id="2a504-125">Cela s’applique également à la très, régulièrement utilisée [Camera.main](https://docs.unity3d.com/ScriptReference/Camera-main.html).</span><span class="sxs-lookup"><span data-stu-id="2a504-125">This also applies to to the very, regularly used [Camera.main](https://docs.unity3d.com/ScriptReference/Camera-main.html).</span></span> <span data-ttu-id="2a504-126">*Camera.main* utilise en fait juste *[FindGameObjectsWithTag()](https://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html)* en dessous, qui recherche coûteuse de votre graphique de scène pour un objet appareil photo avec la *« MainCamera »*  balise.</span><span class="sxs-lookup"><span data-stu-id="2a504-126">*Camera.main* actually just uses *[FindGameObjectsWithTag()](https://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html)* underneath which expensively searches your scene graph for a camera object with the *"MainCamera"* tag.</span></span>

```CS
using UnityEngine;
using System.Collections;

public class ExampleClass : MonoBehaviour
{
    private Camera cam;
    private CustomComponent comp;

    void Start() 
    {
        cam = Camera.main;
        comp = GetComponent<CustomComponent>();
    }

    void Update()
    {
        // Good
        this.transform.position = cam.transform.position + cam.transform.forward * 10.0f;

        // Bad
        this.transform.position = Camera.main.transform.position + Camera.main.transform.forward * 10.0f;

        // Good
        comp.DoSomethingAwesome();

        // Bad
        GetComponent<CustomComponent>().DoSomethingAwesome();
    }
}
```

>[!NOTE] 
> <span data-ttu-id="2a504-127">Éviter GetComponent(string)</span><span class="sxs-lookup"><span data-stu-id="2a504-127">Avoid GetComponent(string)</span></span> <br/>
> <span data-ttu-id="2a504-128">Lorsque vous utilisez  *[GetComponent()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* , il existe un certain nombre de surcharges différentes.</span><span class="sxs-lookup"><span data-stu-id="2a504-128">When using *[GetComponent()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)*, there are a handful of different overloads.</span></span> <span data-ttu-id="2a504-129">Il est important de toujours utiliser les implémentations de Type en fonction et jamais la surcharge de recherche basé sur chaîne.</span><span class="sxs-lookup"><span data-stu-id="2a504-129">It is important to always use the Type based implementations and never the string-based searching overload.</span></span> <span data-ttu-id="2a504-130">La recherche par la chaîne dans votre scène est considérablement plus coûteuse que la recherche par Type.</span><span class="sxs-lookup"><span data-stu-id="2a504-130">Searching by string in your scene is significantly more costly than searching by Type.</span></span> <br/>
> <span data-ttu-id="2a504-131">(Bon) Composant GetComponent (Type type)</span><span class="sxs-lookup"><span data-stu-id="2a504-131">(Good) Component GetComponent(Type type)</span></span> <br/>
> <span data-ttu-id="2a504-132">(Bon) T GetComponent\<T > ()</span><span class="sxs-lookup"><span data-stu-id="2a504-132">(Good) T GetComponent\<T>()</span></span> <br/>
> <span data-ttu-id="2a504-133">(Incorrect) Composant GetComponent(string) ></span><span class="sxs-lookup"><span data-stu-id="2a504-133">(Bad) Component GetComponent(string)></span></span> <br/>

#### <a name="avoid-expensive-operations"></a><span data-ttu-id="2a504-134">Éviter les opérations coûteuses</span><span class="sxs-lookup"><span data-stu-id="2a504-134">Avoid expensive operations</span></span>

1) <span data-ttu-id="2a504-135">**Évitez d’utiliser [LINQ](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/getting-started-with-linq)**</span><span class="sxs-lookup"><span data-stu-id="2a504-135">**Avoid use of [LINQ](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/getting-started-with-linq)**</span></span>

    <span data-ttu-id="2a504-136">Même si LINQ peut être très propre et facile à lire et écrire, elle nécessite généralement beaucoup plus de calcul et plus particulièrement l’allocation de mémoire que l’écriture de l’algorithme manuellement.</span><span class="sxs-lookup"><span data-stu-id="2a504-136">Although LINQ can be very clean and easy to read and write, it generally requires much more computation and particularly more memory allocation than writing the algorithm out manually.</span></span>

    ```CS
    // Example Code
    using System.Linq;

    List<int> data = new List<int>();
    data.Any(x => x > 10);

    var result = from x in data
                 where x > 10
                 select x;
    ```

2) <span data-ttu-id="2a504-137">**API Unity courantes**</span><span class="sxs-lookup"><span data-stu-id="2a504-137">**Common Unity APIs**</span></span>

    <span data-ttu-id="2a504-138">Certaines API Unity, bien qu’utile, peut être très coûteux à exécuter.</span><span class="sxs-lookup"><span data-stu-id="2a504-138">Certain Unity APIs, although useful, can be very expensive to execute.</span></span> <span data-ttu-id="2a504-139">La plupart d'entre eux implique la recherche de votre graphique de scène entière pour une liste des GameObjects correspondants.</span><span class="sxs-lookup"><span data-stu-id="2a504-139">Most of these involve searching your entire scene graph for some matching list of GameObjects.</span></span> <span data-ttu-id="2a504-140">Ces opérations peuvent généralement être évitées en mise en cache des références ou en implémentant un composant de gestionnaire pour les GameObjects en question suivre les références lors de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="2a504-140">These operations can generally be avoided by caching references or implementing a manager component for the GameObjects in question to track the references at runtime.</span></span>

        GameObject.SendMessage()
        GameObject.BroadcastMessage()
        UnityEngine.Object.Find()
        UnityEngine.Object.FindWithTag()
        UnityEngine.Object.FindObjectOfType()
        UnityEngine.Object.FindObjectsOfType()
        UnityEngine.Object.FindGameObjectsWithTag()
        UnityEngine.Object.FindGameObjectsWithTag()

>[!NOTE]
> <span data-ttu-id="2a504-141">*[SendMessage()](https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html)*  et *[BroadcastMessage()](https://docs.unity3d.com/ScriptReference/GameObject.BroadcastMessage.html)* doivent être supprimés à tout prix.</span><span class="sxs-lookup"><span data-stu-id="2a504-141">*[SendMessage()](https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html)* and *[BroadcastMessage()](https://docs.unity3d.com/ScriptReference/GameObject.BroadcastMessage.html)* should be eliminated at all costs.</span></span> <span data-ttu-id="2a504-142">Ces fonctions peuvent être l’ordre de 1 000 x plus lent que les appels de fonction direct.</span><span class="sxs-lookup"><span data-stu-id="2a504-142">These functions can be on the order of 1000x slower than direct function calls.</span></span>

3) <span data-ttu-id="2a504-143">**Méfiez-vous des conversions boxing**</span><span class="sxs-lookup"><span data-stu-id="2a504-143">**Beware of boxing**</span></span>

    <span data-ttu-id="2a504-144">[Boxing](https://docs.microsoft.com/dotnet/csharp/programming-guide/types/boxing-and-unboxing) est un concept fondamental de la C# langage et exécution.</span><span class="sxs-lookup"><span data-stu-id="2a504-144">[Boxing](https://docs.microsoft.com/dotnet/csharp/programming-guide/types/boxing-and-unboxing) is a core concept of the C# language and runtime.</span></span> <span data-ttu-id="2a504-145">Il est le processus d’encapsuler des valeurs de variables telles que char, int, bool, etc. dans des variables de référence typée.</span><span class="sxs-lookup"><span data-stu-id="2a504-145">It is the process of wrapping value-typed variables such as char, int, bool, etc. into reference-typed variables.</span></span> <span data-ttu-id="2a504-146">Quand une variable typée à la valeur est « boxed », il est encapsulé à l’intérieur d’un System.Object qui est stocké sur le tas managé.</span><span class="sxs-lookup"><span data-stu-id="2a504-146">When a value-typed variable is "boxed", it is wrapped inside of a System.Object which is stored on the managed heap.</span></span> <span data-ttu-id="2a504-147">Par conséquent, la mémoire est allouée et finalement lorsque supprimé doit être traité par le garbage collector.</span><span class="sxs-lookup"><span data-stu-id="2a504-147">Thus, memory is allocated and eventually when disposed must be processed by the garbage collector.</span></span> <span data-ttu-id="2a504-148">Ces allocations et les désallocations entraînent une baisse des performances et dans de nombreux scénarios ne sont pas nécessaires ou peuvent être facilement remplacées par une alternative moins coûteuse.</span><span class="sxs-lookup"><span data-stu-id="2a504-148">These allocations and deallocations incur a performance cost and in many scenarios are unnecessary or can be easily replaced by a less expensive alternative.</span></span>

#### <a name="repeating-code-paths"></a><span data-ttu-id="2a504-149">Chemins de code extensible</span><span class="sxs-lookup"><span data-stu-id="2a504-149">Repeating code paths</span></span>

<span data-ttu-id="2a504-150">Les fonctions de rappel Unity extensibles (ex.)</span><span class="sxs-lookup"><span data-stu-id="2a504-150">Any repeating Unity callback functions (i.e</span></span> <span data-ttu-id="2a504-151">Mise à jour) qui sont exécutées plusieurs fois par seconde et/ou de frame doit être écrits très soigneusement.</span><span class="sxs-lookup"><span data-stu-id="2a504-151">Update) that are executed many times per second and/or frame should be written very carefully.</span></span> <span data-ttu-id="2a504-152">Les opérations coûteuses ici a impact énorme et cohérente sur les performances.</span><span class="sxs-lookup"><span data-stu-id="2a504-152">Any expensive operations here will have huge and consistent impact on performance.</span></span>

1) <span data-ttu-id="2a504-153">**Fonctions de rappel vide**</span><span class="sxs-lookup"><span data-stu-id="2a504-153">**Empty callback functions**</span></span>

    <span data-ttu-id="2a504-154">Bien que le code ci-dessous peut sembler inoffensif à laisser dans votre application, en particulier depuis chaque Unity script automatique initialise avec ce bloc de code, ces rappels vides peuvent en réalité devenir très coûteux.</span><span class="sxs-lookup"><span data-stu-id="2a504-154">Although the code below may seem innocent to leave in your application, especially since every Unity script auto-initializes with this code block, these empty callbacks can actually become very expensive.</span></span> <span data-ttu-id="2a504-155">Unity fonctionne dans les deux sens sur une limite de code gérés/non gérés, entre le code de UnityEngine et de votre code d’application.</span><span class="sxs-lookup"><span data-stu-id="2a504-155">Unity operates back and forth over an unmanaged/managed code boundary, between UnityEngine code and your application code.</span></span> <span data-ttu-id="2a504-156">Contexte de basculement de ce pont est relativement coûteuse même s’il n’a rien à exécuter.</span><span class="sxs-lookup"><span data-stu-id="2a504-156">Context switching over this bridge is fairly expensive even if there is nothing to execute.</span></span> <span data-ttu-id="2a504-157">Cela devient particulièrement problématique si votre application comporte des centaines de GameObjects avec des composants qui ont des rappels Unity extensibles vides.</span><span class="sxs-lookup"><span data-stu-id="2a504-157">This becomes especially problematic if your app has 100's of GameObjects with components that have empty repeating Unity callbacks.</span></span>

    ```CS
    void Update()
    {
    }
    ```

>[!NOTE]
> <span data-ttu-id="2a504-158">Update() est la manifestation la plus commune de ce problème de performances, mais d’autres rappels Unity extensibles semblable à celui-ci peuvent être tout aussi mauvais si pas pire : FixedUpdate(), LateUpdate(), OnPostRender", OnPreRender(), OnRenderImage(), etc.</span><span class="sxs-lookup"><span data-stu-id="2a504-158">Update() is the most common manifestation of this performance issue but other repeating Unity callbacks such as the following can be equally as bad if not worse: FixedUpdate(), LateUpdate(), OnPostRender", OnPreRender(), OnRenderImage(), etc.</span></span> 

2) <span data-ttu-id="2a504-159">**Opérations de favoriser en cours d’exécution une fois par frame**</span><span class="sxs-lookup"><span data-stu-id="2a504-159">**Operations to favor running once per frame**</span></span>

    <span data-ttu-id="2a504-160">Les API Unity suivantes sont des opérations courantes pour de nombreuses applications HOLOGRAPHIQUE.</span><span class="sxs-lookup"><span data-stu-id="2a504-160">The following Unity APIs are common operations for many Holographic Apps.</span></span> <span data-ttu-id="2a504-161">Bien que pas toujours possible, les résultats de ces fonctions peuvent être très couramment calculées une fois et les résultats de nouveau utilisé à travers l’application pour une trame donnée.</span><span class="sxs-lookup"><span data-stu-id="2a504-161">Although not always possible, the results from these functions can very commonly be computed once and the results re-utilized across the application for a given frame.</span></span>

    <span data-ttu-id="2a504-162">(a) en général il est conseillé de disposer d’une classe Singleton dédié ou un service pour gérer votre regard Raycast dans la scène et de réutiliser ensuite ce résultat dans tous les autres composants de la scène, au lieu d’effectuer des opérations Raycast répétées et fondamentalement identiques par chaque composant.</span><span class="sxs-lookup"><span data-stu-id="2a504-162">a) Generally it is good practice to have a dedicated Singleton class or service to handle your gaze Raycast into the scene and then re-use this result in all other scene components, instead of making repeated and essentially identical Raycast operations by each component.</span></span> <span data-ttu-id="2a504-163">Bien entendu, certaines applications peuvent nécessiter raycasts à partir de différentes origines ou par rapport à différents [LayerMasks](https://docs.unity3d.com/ScriptReference/LayerMask.html).</span><span class="sxs-lookup"><span data-stu-id="2a504-163">Of course, some applications may require raycasts from different origins or against different [LayerMasks](https://docs.unity3d.com/ScriptReference/LayerMask.html).</span></span>

        UnityEngine.Physics.Raycast()
        UnityEngine.Physics.RaycastAll()

    <span data-ttu-id="2a504-164">(b) éviter les opérations de GetComponent() dans les rappels Unity répétées comme Update() par [mise en cache des références](#cache-references) dans Start() ou Awake()</span><span class="sxs-lookup"><span data-stu-id="2a504-164">b) Avoid GetComponent() operations in repeated Unity callbacks like Update() by [caching references](#cache-references) in Start() or Awake()</span></span>

        UnityEngine.Object.GetComponent()

    <span data-ttu-id="2a504-165">(c) il est conseillé à instancier tous les objets, si possible, à l’initialisation et l’utilisation [le pool d’objets](#object-pooling) à recycler et réutiliser les GameObjects tout au long de l’exécution de votre application</span><span class="sxs-lookup"><span data-stu-id="2a504-165">c) It is good practice to instantiate all objects, if possible, at initialization and use [object pooling](#object-pooling) to recycle and re-use GameObjects throughout runtime of your application</span></span>

        UnityEngine.Object.Instantiate()

3) <span data-ttu-id="2a504-166">**Éviter les interfaces et les constructions virtuelles**</span><span class="sxs-lookup"><span data-stu-id="2a504-166">**Avoid interfaces and virtual constructs**</span></span>

    <span data-ttu-id="2a504-167">Appels de fonction via des interfaces vs direct objets ou de l’appel de fonctions virtuelles peuvent souvent être beaucoup plus onéreux que l’utilisation de constructions directe ou des appels de fonction direct.</span><span class="sxs-lookup"><span data-stu-id="2a504-167">Invoking function calls through interfaces vs direct objects or calling virtual functions can often times be much more expensive than utilizing direct constructs or direct function calls.</span></span> <span data-ttu-id="2a504-168">Si la fonction virtuelle ou l’interface n’est pas nécessaire, elle doit être supprimée.</span><span class="sxs-lookup"><span data-stu-id="2a504-168">If the virtual function or interface is unnecessary, then it should be removed.</span></span> <span data-ttu-id="2a504-169">Toutefois, les performances de ces approches d’accès valent généralement le compromis si leur utilisation simplifie la collaboration de développement, la lisibilité du code et la maintenabilité du code.</span><span class="sxs-lookup"><span data-stu-id="2a504-169">However, the performance hit for these approaches are generally worth the trade-off if utilizing them simplifies development collaboration, code readability, and code maintainability.</span></span> 

4) <span data-ttu-id="2a504-170">**Éviter les structures de passage par valeur**</span><span class="sxs-lookup"><span data-stu-id="2a504-170">**Avoid passing structs by value**</span></span>

    <span data-ttu-id="2a504-171">Contrairement aux classes, structs sont des types de valeur, et quand il est passé directement à une fonction, leur contenu est copié dans une instance nouvellement créée.</span><span class="sxs-lookup"><span data-stu-id="2a504-171">Unlike classes, structs are value-types and when passed directly to a function, their contents are copied into a newly created instance.</span></span> <span data-ttu-id="2a504-172">Cette copie ajoute le coût, ainsi que la mémoire supplémentaire sur la pile de l’UC.</span><span class="sxs-lookup"><span data-stu-id="2a504-172">This copy adds CPU cost as well as additional memory on the stack.</span></span> <span data-ttu-id="2a504-173">Pour les petits structs, l’effet est généralement très minimes et par conséquent acceptable.</span><span class="sxs-lookup"><span data-stu-id="2a504-173">For small structs, the effect is usually very minimal and thus acceptable.</span></span> <span data-ttu-id="2a504-174">Toutefois, pour les fonctions appelées plusieurs fois chaque trame ainsi que des fonctions en prenant les structures de grande taille, si possible modifier la définition de fonction pour passer par référence.</span><span class="sxs-lookup"><span data-stu-id="2a504-174">However, for functions repeatedly invoked every frame as well as functions taking large structs, if possible modify the function definition to pass by reference.</span></span> [<span data-ttu-id="2a504-175">En savoir plus ici</span><span class="sxs-lookup"><span data-stu-id="2a504-175">Learn more here</span></span>](https://docs.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/how-to-know-the-difference-passing-a-struct-and-passing-a-class-to-a-method)

#### <a name="miscellaneous"></a><span data-ttu-id="2a504-176">Divers</span><span class="sxs-lookup"><span data-stu-id="2a504-176">Miscellaneous</span></span>

1) <span data-ttu-id="2a504-177">**Physique**</span><span class="sxs-lookup"><span data-stu-id="2a504-177">**Physics**</span></span>

    <span data-ttu-id="2a504-178">(a) en règle générale, le plus simple pour améliorer physique consiste à limiter la quantité de temps passé sur physique ou le nombre d’itérations par seconde.</span><span class="sxs-lookup"><span data-stu-id="2a504-178">a) Generally, easiest way to improve physics is to limit the amount of time spent on Physics or the number of iterations per second.</span></span> <span data-ttu-id="2a504-179">Bien sûr, cela réduira la précision de la simulation.</span><span class="sxs-lookup"><span data-stu-id="2a504-179">Of course, this will reduce simulation accuracy.</span></span> <span data-ttu-id="2a504-180">Consultez [TimeManager](https://docs.unity3d.com/Manual/class-TimeManager.html) dans Unity</span><span class="sxs-lookup"><span data-stu-id="2a504-180">See [TimeManager](https://docs.unity3d.com/Manual/class-TimeManager.html) in Unity</span></span>

    <span data-ttu-id="2a504-181">(b) le type de colliders dans Unity présentent des caractéristiques de performances très différents.</span><span class="sxs-lookup"><span data-stu-id="2a504-181">b) The type of colliders in Unity have widely different performance characteristics.</span></span> <span data-ttu-id="2a504-182">L’ordre ci-dessous répertorie les plupart des colliders performante au moins performante colliders de gauche à droite.</span><span class="sxs-lookup"><span data-stu-id="2a504-182">The order below lists the most performant colliders to least performant colliders from left to right.</span></span> <span data-ttu-id="2a504-183">Il est plus important d’éviter Colliders maillage qui sont beaucoup plus cher que les colliders primitifs.</span><span class="sxs-lookup"><span data-stu-id="2a504-183">It is most important to avoid Mesh Colliders which are substantially more expensive than the primitive colliders.</span></span>

        Sphere < Capsule < Box <<< Mesh (Convex) < Mesh (non-Convex)

    <span data-ttu-id="2a504-184">Consultez [Unity physique meilleures pratiques](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices) pour plus d’informations</span><span class="sxs-lookup"><span data-stu-id="2a504-184">See [Unity Physics Best Practices](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices) for more info</span></span>

2) <span data-ttu-id="2a504-185">**Animations**</span><span class="sxs-lookup"><span data-stu-id="2a504-185">**Animations**</span></span>

    <span data-ttu-id="2a504-186">Désactiver les animations inactives en désactivant le composant d’animation (la désactivation de l’objet de jeu ne sont pas avoir le même effet).</span><span class="sxs-lookup"><span data-stu-id="2a504-186">Disable idle animations by disabling the Animator component (disabling the game object won't have the same effect).</span></span> <span data-ttu-id="2a504-187">Évitez les modèles de conception où un animateur se trouve dans une boucle de définition d’une valeur à la même chose.</span><span class="sxs-lookup"><span data-stu-id="2a504-187">Avoid design patterns where an animator sits in a loop setting a value to the same thing.</span></span> <span data-ttu-id="2a504-188">Il existe une charge considérable pour cette technique, sans aucune incidence sur l’application.</span><span class="sxs-lookup"><span data-stu-id="2a504-188">There is considerable overhead for this technique, with no effect on the application.</span></span> [<span data-ttu-id="2a504-189">En savoir plus ici.</span><span class="sxs-lookup"><span data-stu-id="2a504-189">Learn more here.</span></span>](https://docs.unity3d.com/Manual/MecanimPeformanceandOptimization.html)

3) <span data-ttu-id="2a504-190">**Algorithmes complexes**</span><span class="sxs-lookup"><span data-stu-id="2a504-190">**Complex algorithms**</span></span>

    <span data-ttu-id="2a504-191">Si votre application utilise des algorithmes complexes telles que la cinématique inverse, la recherche de chemin d’accès, etc., cherchez à une approche plus simple de trouver ou d’ajuster les paramètres appropriés pour leurs performances</span><span class="sxs-lookup"><span data-stu-id="2a504-191">If your application is using complex algorithms such as inverse kinematics, path finding, etc, look to find a simpler approach or adjust relevant settings for their performance</span></span>

## <a name="cpu-to-gpu-performance-recommendations"></a><span data-ttu-id="2a504-192">Recommandations relatives aux performances de l’UC à GPU</span><span class="sxs-lookup"><span data-stu-id="2a504-192">CPU-to-GPU performance recommendations</span></span>

<span data-ttu-id="2a504-193">En règle générale, les performances de l’UC à GPU est fourni jusqu'à la **les appels de dessin** soumis à la carte graphique.</span><span class="sxs-lookup"><span data-stu-id="2a504-193">Generally, CPU-to-GPU performance comes down to the **draw calls** submitted to the graphics card.</span></span> <span data-ttu-id="2a504-194">Pour améliorer les performances, appels de dessin doivent être programmées de façon stratégique **a) réduit** ou **b) restructuré** pour des résultats optimaux.</span><span class="sxs-lookup"><span data-stu-id="2a504-194">To improve performance, draw calls need to be strategically **a) reduced** or **b) restructured** for optimal results.</span></span> <span data-ttu-id="2a504-195">Étant donné que les appels de dessin eux-mêmes sont gourmandes en ressources, ce qui réduit les réduira travail global requis.</span><span class="sxs-lookup"><span data-stu-id="2a504-195">Since draw calls themselves are resource-intensive, reducing them will reduce overall work required.</span></span> <span data-ttu-id="2a504-196">En outre, les modifications entre les appels de dessin requiert la validation coûteux et étapes de traduction dans le pilote graphique d’état et par conséquent, la restructuration de votre application appels de dessin pour limiter les changements d’état (ex.)</span><span class="sxs-lookup"><span data-stu-id="2a504-196">Further, state changes between draw calls requires costly validation and translation steps in the graphics driver and thus, restructuring of your application's draw calls to limit state changes(i.e</span></span> <span data-ttu-id="2a504-197">différents, etc.) peut améliorer les performances.</span><span class="sxs-lookup"><span data-stu-id="2a504-197">different materials, etc) can boost performance.</span></span>

<span data-ttu-id="2a504-198">Unity possède un excellent article qui donne une vue d’ensemble et explore le traitement par lot des appels de dessin pour leur plateforme.</span><span class="sxs-lookup"><span data-stu-id="2a504-198">Unity has a great article that gives an overview and dives into batching draw calls for their platform.</span></span>
- [<span data-ttu-id="2a504-199">Unity dessiner le traitement par lot des appels</span><span class="sxs-lookup"><span data-stu-id="2a504-199">Unity Draw Call Batching</span></span>](https://docs.unity3d.com/Manual/DrawCallBatching.html)

#### <a name="single-pass-instanced-rendering"></a><span data-ttu-id="2a504-200">Rendu instanciées passe unique</span><span class="sxs-lookup"><span data-stu-id="2a504-200">Single pass instanced rendering</span></span>

<span data-ttu-id="2a504-201">Rendu Instanced unique dans Unity permet les appels de dessin pour chaque œil être réduit à l’appel de dessin instancié une seule.</span><span class="sxs-lookup"><span data-stu-id="2a504-201">Single Pass Instanced Rendering in Unity allows for draw calls for each eye to be reduced down to one instanced draw call.</span></span> <span data-ttu-id="2a504-202">En raison de la cohérence du cache entre les deux appels de dessin, il existe également une amélioration des performances sur le GPU également.</span><span class="sxs-lookup"><span data-stu-id="2a504-202">Due to cache coherency between two draw calls, there is also some performance improvement on the GPU as well.</span></span>

<span data-ttu-id="2a504-203">Pour activer cette fonctionnalité dans votre projet Unity</span><span class="sxs-lookup"><span data-stu-id="2a504-203">To enable this feature in your Unity Project</span></span>
1)  <span data-ttu-id="2a504-204">Ouvrez **paramètres du lecteur XR** (accédez à **modifier** > **paramètres du projet** > **Player**  >  **XR paramètres**)</span><span class="sxs-lookup"><span data-stu-id="2a504-204">Open **Player XR Settings** (go to **Edit** > **Project Settings** > **Player** > **XR Settings**)</span></span>
2) <span data-ttu-id="2a504-205">Sélectionnez **unique passer une instance créée** à partir de la **méthode de rendu stéréo** menu déroulant (**virtuel pris en charge de réalité** case doit être cochée)</span><span class="sxs-lookup"><span data-stu-id="2a504-205">Select **Single Pass Instanced** from the **Stereo Rendering Method** drop-down menu (**Virtual Reality Supported** checkbox must be checked)</span></span>

<span data-ttu-id="2a504-206">Pour plus d’informations avec cette approche de rendu, lisez les articles suivants à partir d’Unity.</span><span class="sxs-lookup"><span data-stu-id="2a504-206">Read the following articles from Unity for details with this rendering approach.</span></span>
- [<span data-ttu-id="2a504-207">Comment optimiser les performances des AR et VR avec rendu stéréo avancé</span><span class="sxs-lookup"><span data-stu-id="2a504-207">How to maximize AR and VR performance with advanced stereo rendering</span></span>](https://blogs.unity3d.com/2017/11/21/how-to-maximize-ar-and-vr-performance-with-advanced-stereo-rendering/)
- [<span data-ttu-id="2a504-208">L’instanciation unique Pass</span><span class="sxs-lookup"><span data-stu-id="2a504-208">Single Pass Instancing</span></span>](https://docs.unity3d.com/Manual/SinglePassInstancing.html) 

>[!NOTE]
> <span data-ttu-id="2a504-209">Un problème courant avec unique passer instancié rendu se produit si les développeurs ont déjà des nuanceurs personnalisés existants non écrits pour l’instanciation.</span><span class="sxs-lookup"><span data-stu-id="2a504-209">One common issue with Single Pass Instanced Rendering occurs if developers already have existing custom shaders not written for instancing.</span></span> <span data-ttu-id="2a504-210">Après avoir activé cette fonctionnalité, les développeurs remarquerez certains rendu uniquement GameObjects d’un oeil.</span><span class="sxs-lookup"><span data-stu-id="2a504-210">After enabling this feature, developers may notice some GameObjects only render in one eye.</span></span> <span data-ttu-id="2a504-211">Il s’agit comme les nuanceurs personnalisés associés n’ont pas les propriétés appropriées pour l’instanciation.</span><span class="sxs-lookup"><span data-stu-id="2a504-211">This is because the associated custom shaders do not have the appropriate properties for instancing.</span></span>
>
> <span data-ttu-id="2a504-212">Consultez [unique passer stéréo rendu pour HoloLens](https://docs.unity3d.com/Manual/SinglePassStereoRenderingHoloLens.html) à partir d’Unity pour savoir comment résoudre le problème</span><span class="sxs-lookup"><span data-stu-id="2a504-212">See [Single Pass Stereo Rendering for HoloLens](https://docs.unity3d.com/Manual/SinglePassStereoRenderingHoloLens.html) from Unity for how to address this problem</span></span>

#### <a name="static-batching"></a><span data-ttu-id="2a504-213">Le traitement par lots statique</span><span class="sxs-lookup"><span data-stu-id="2a504-213">Static batching</span></span>

<span data-ttu-id="2a504-214">Unity est en mesure de nombreux objets statiques afin de réduire les appels de dessin au GPU du lot.</span><span class="sxs-lookup"><span data-stu-id="2a504-214">Unity is able to batch many static objects to reduce draw calls to the GPU.</span></span> <span data-ttu-id="2a504-215">Le traitement par lots statique fonctionne pour la plupart des [convertisseur](https://docs.unity3d.com/ScriptReference/Renderer.html) objets dans Unity qui **1) partagent le même matériel** et **2) sont toutes marquées en tant que *statique***  () Sélectionnez un objet dans Unity et cliquez sur la case à cocher dans le coin supérieur droit de l’inspecteur).</span><span class="sxs-lookup"><span data-stu-id="2a504-215">Static Batching works for most [Renderer](https://docs.unity3d.com/ScriptReference/Renderer.html) objects in Unity that **1) share the same material** and **2) are all marked as *Static*** (Select an object in Unity and click the checkbox in the top right of the inspector).</span></span> <span data-ttu-id="2a504-216">La mention GameObjects *statique* ne peut pas être déplacé dans l’ensemble du runtime de votre application.</span><span class="sxs-lookup"><span data-stu-id="2a504-216">GameObjects marked as *Static* cannot be moved throughout your application's runtime.</span></span> <span data-ttu-id="2a504-217">Par conséquent, le traitement par lots statique peut être difficile de tirer parti de HoloLens où pratiquement chaque objet doit être placé, déplacées, à l’échelle, etc. Pour des casques IMMERSIFS, le traitement par lots statique peut considérablement réduire les appels de dessin et améliore donc les performances.</span><span class="sxs-lookup"><span data-stu-id="2a504-217">Thus, static batching can be difficult to leverage on HoloLens where virtually every object needs to be placed, moved, scaled, etc. For immersive headsets, static batching can dramatically reduce draw calls and thus improve performance.</span></span>

<span data-ttu-id="2a504-218">Lecture *le traitement par lots statique* sous [dessiner appeler le traitement par lots dans Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) pour plus d’informations.</span><span class="sxs-lookup"><span data-stu-id="2a504-218">Read *Static Batching* under [Draw Call Batching in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) for more details.</span></span>

#### <a name="dynamic-batching"></a><span data-ttu-id="2a504-219">Le traitement par lots dynamique</span><span class="sxs-lookup"><span data-stu-id="2a504-219">Dynamic batching</span></span>

<span data-ttu-id="2a504-220">Dans la mesure où il est problématique pour marquer des objets en tant que *statique* pour le développement HoloLens, dynamique de traitement par lot peut être un excellent outil pour pallier cette absence de fonctionnalité.</span><span class="sxs-lookup"><span data-stu-id="2a504-220">Since it is problematic to mark objects as *Static* for HoloLens development, dynamic batching can be a great tool to compensate for this lacking feature.</span></span> <span data-ttu-id="2a504-221">Bien sûr, il est peut également être utile dans des casques IMMERSIFS.</span><span class="sxs-lookup"><span data-stu-id="2a504-221">Of course, it is can also be useful on immersive headsets as well.</span></span> <span data-ttu-id="2a504-222">Traitement par lot de manière dynamique dans Unity peut être difficile cependant activer car doit GameObjects **a) partage le même document** et **b) répondent à une longue liste d’autres critères**.</span><span class="sxs-lookup"><span data-stu-id="2a504-222">Dynamic batching in Unity can be difficult though to enable because GameObjects must **a) share the same Material** and **b) meet a long list of other criteria**.</span></span>

<span data-ttu-id="2a504-223">Lecture *le traitement par lots dynamique* sous [dessiner appeler le traitement par lots dans Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) pour obtenir la liste complète.</span><span class="sxs-lookup"><span data-stu-id="2a504-223">Read *Dynamic Batching* under [Draw Call Batching in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) for the full list.</span></span> <span data-ttu-id="2a504-224">En règle générale, GameObjects deviennent non valides pour être traités par lot dynamiquement, car les données de maillage associé peuvent être pas plus de 300 vertex.</span><span class="sxs-lookup"><span data-stu-id="2a504-224">Most commonly, GameObjects become invalid to be batched dynamically because the associated mesh data can be no more than 300 vertices.</span></span>

#### <a name="other-techniques"></a><span data-ttu-id="2a504-225">autres techniques</span><span class="sxs-lookup"><span data-stu-id="2a504-225">Other techniques</span></span>

<span data-ttu-id="2a504-226">Le traitement par lots peut uniquement se produire si plusieurs GameObjects sont en mesure de partager le même matériel.</span><span class="sxs-lookup"><span data-stu-id="2a504-226">Batching can only occur if multiple GameObjects are able to share the same material.</span></span> <span data-ttu-id="2a504-227">En général, cela sera bloquée par la nécessité de GameObjects avoir une texture unique pour leurs documents respectifs.</span><span class="sxs-lookup"><span data-stu-id="2a504-227">Typically this will be blocked by the need for GameObjects to have a unique texture for their respective Material.</span></span> <span data-ttu-id="2a504-228">Il est courant de combiner des Textures dans une Texture volumineuse, une méthode appelée [Texture Atlasing](https://en.wikipedia.org/wiki/Texture_atlas).</span><span class="sxs-lookup"><span data-stu-id="2a504-228">It is common to combine Textures into one big Texture, a method known as [Texture Atlasing](https://en.wikipedia.org/wiki/Texture_atlas).</span></span>

<span data-ttu-id="2a504-229">En outre, il est généralement préférable de combiner les mailles en un GameObject si possible et raisonnable.</span><span class="sxs-lookup"><span data-stu-id="2a504-229">Further, it is generally preferable to combine meshes into one GameObject where possible and reasonable.</span></span> <span data-ttu-id="2a504-230">Chaque convertisseur dans Unity aura il est associé à dessin appel (s) par rapport à l’envoi d’une maille combinée sous un convertisseur.</span><span class="sxs-lookup"><span data-stu-id="2a504-230">Each Renderer in Unity will have it's associated draw call(s) versus submitting a combined mesh under one Renderer.</span></span> 

>[!NOTE]
> <span data-ttu-id="2a504-231">Modification des propriétés de Renderer.material lors de l’exécution pour créer une copie de la matière et par conséquent susceptibles d’interrompre le traitement par lots.</span><span class="sxs-lookup"><span data-stu-id="2a504-231">Modifying properties of Renderer.material at runtime will create a copy of the Material and thus potentially break batching.</span></span> <span data-ttu-id="2a504-232">Utilisez Renderer.sharedMaterial pour modifier les propriétés de matériel partagées entre les GameObjects.</span><span class="sxs-lookup"><span data-stu-id="2a504-232">Use Renderer.sharedMaterial to modify shared material properties across GameObjects.</span></span>

## <a name="gpu-performance-recommendations"></a><span data-ttu-id="2a504-233">Recommandations relatives aux performances de GPU</span><span class="sxs-lookup"><span data-stu-id="2a504-233">GPU performance recommendations</span></span>

<span data-ttu-id="2a504-234">En savoir plus sur [optimisation de rendu de graphiques dans Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games)</span><span class="sxs-lookup"><span data-stu-id="2a504-234">Learn more about [optimizing graphics rendering in Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games)</span></span> 

### <a name="optimize-depth-buffer-sharing"></a><span data-ttu-id="2a504-235">Optimiser le partage de mémoire tampon de profondeur</span><span class="sxs-lookup"><span data-stu-id="2a504-235">Optimize depth buffer sharing</span></span>

<span data-ttu-id="2a504-236">Il est généralement recommandé d’activer **partage de mémoire tampon de profondeur** sous **paramètres du lecteur XR** afin d’optimiser [la stabilité hologramme](Hologram-stability.md).</span><span class="sxs-lookup"><span data-stu-id="2a504-236">It is generally recommended to enable **Depth buffer sharing** under **Player XR Settings** to optimize for [hologram stability](Hologram-stability.md).</span></span> <span data-ttu-id="2a504-237">Lors de l’activation basée sur une profondeur de reprojection minute avec ce paramètre Toutefois, il est recommandé de sélectionner **format de la profondeur de 16 bits** au lieu de **format de 24 bits profondeur**.</span><span class="sxs-lookup"><span data-stu-id="2a504-237">When enabling depth-based late-stage reprojection with this setting however, it is recommended to select **16-bit depth format** instead of **24-bit depth format**.</span></span> <span data-ttu-id="2a504-238">La volonté de mémoires tampons de profondeur de 16 bits réduit considérablement la bande passante (et par conséquent, l’alimentation) associé au trafic de mémoire tampon de profondeur.</span><span class="sxs-lookup"><span data-stu-id="2a504-238">The 16-bit depth buffers will drastically reduces the bandwidth (and thus power) associated with depth buffer traffic.</span></span> <span data-ttu-id="2a504-239">Cela peut s’avérer efficace en puissance, mais il est uniquement applicable pour les expériences avec une plage de profondeur petit comme [z lutte](https://en.wikipedia.org/wiki/Z-fighting) est susceptible de se produire avec 16 bits à 24 bits.</span><span class="sxs-lookup"><span data-stu-id="2a504-239">This can be a big power win, but is only applicable for experiences with a small depth range as [z-fighting](https://en.wikipedia.org/wiki/Z-fighting) is more likely to occur with 16-bit than 24-bit.</span></span> <span data-ttu-id="2a504-240">Pour éviter ces artefacts, modifier les plans de découpage près/lointain de le [appareil photo Unity](https://docs.unity3d.com/Manual/class-Camera.html) pour prendre en compte pour la précision inférieure.</span><span class="sxs-lookup"><span data-stu-id="2a504-240">To avoid these artifacts, modify the near/far clip planes of the [Unity camera](https://docs.unity3d.com/Manual/class-Camera.html) to account for the lower precision.</span></span> <span data-ttu-id="2a504-241">Pour les applications basées sur HoloLens, un plan de découpage lointain de 50 millions au lieu de la valeur par défaut de Unity 1000 m peut éliminer généralement un z fighting.</span><span class="sxs-lookup"><span data-stu-id="2a504-241">For HoloLens-based applications, a far clip plane of 50m instead of the Unity default 1000m can generally eliminate any z-fighting.</span></span>

### <a name="reduce-poly-count"></a><span data-ttu-id="2a504-242">Réduire le nombre de poly</span><span class="sxs-lookup"><span data-stu-id="2a504-242">Reduce poly count</span></span>

<span data-ttu-id="2a504-243">Nombre de polygone est généralement réduite à l’aide</span><span class="sxs-lookup"><span data-stu-id="2a504-243">Polygon count is usually reduced by either</span></span>
1) <span data-ttu-id="2a504-244">Suppression d’objets dans une scène</span><span class="sxs-lookup"><span data-stu-id="2a504-244">Removing objects from a scene</span></span>
2) <span data-ttu-id="2a504-245">Décimalisation Asset ce qui réduit le nombre de polygones pour une maille donnée</span><span class="sxs-lookup"><span data-stu-id="2a504-245">Asset decimation which reduces the number of polygons for a given mesh</span></span>
3) <span data-ttu-id="2a504-246">Implémentation d’un [système de niveau de détail (LOD)](https://docs.unity3d.com/Manual/LevelOfDetail.html) dans votre application qui restitue éloigné des objets avec une version inférieure-polygone de la même géométrie</span><span class="sxs-lookup"><span data-stu-id="2a504-246">Implementing a [Level of Detail (LOD) System](https://docs.unity3d.com/Manual/LevelOfDetail.html) into your application which renders far away objects with lower-polygon version of the same geometry</span></span>

### <a name="understanding-shaders-in-unity"></a><span data-ttu-id="2a504-247">Nuanceurs de présentation dans Unity</span><span class="sxs-lookup"><span data-stu-id="2a504-247">Understanding shaders in Unity</span></span>

<span data-ttu-id="2a504-248">Une approximation facile à comparer les nuanceurs de performances est d’identifier le nombre moyen d’opérations chaque s’exécute lors de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="2a504-248">An easy approximation to compare shaders in performance is to identify the average number of operations each executes at runtime.</span></span> <span data-ttu-id="2a504-249">Cela est possible facilement dans Unity.</span><span class="sxs-lookup"><span data-stu-id="2a504-249">This can be done easily in Unity.</span></span>

1) <span data-ttu-id="2a504-250">Sélectionnez votre ressource de nuanceur ou sélectionnez un matériau, puis dans le coin supérieur droit de la fenêtre Inspecteur, sélectionnez l’icône d’engrenage, puis **« Sélectionnez nuanceur »**</span><span class="sxs-lookup"><span data-stu-id="2a504-250">Select your shader asset or select a material, then in top right corner of the inspector window, select the gear icon and then **"Select Shader"**</span></span>

    ![Sélectionnez le nuanceur dans Unity](images/Select-shader-unity.png)
2) <span data-ttu-id="2a504-252">La ressource de nuanceur sélectionnée, puis cliquez sur le **« Compilation et l’affichage de code »** bouton sous la fenêtre Inspecteur</span><span class="sxs-lookup"><span data-stu-id="2a504-252">With the shader asset selected, click the **"Compile and show code"** button under the inspector window</span></span>

    ![Compiler le Code de nuanceur dans Unity](images/compile-shader-code-unity.PNG)

3) <span data-ttu-id="2a504-254">Après la compilation, recherchez la section des statistiques dans les résultats avec le nombre d’opérations différents pour le nuanceur de sommets et de pixels (Remarque : des nuanceurs de pixels sont souvent également appelés des nuanceurs de fragment)</span><span class="sxs-lookup"><span data-stu-id="2a504-254">After compiling, look for the statistics section in the results with the number of different operations for both the vertex and pixel shader (Note: pixel shaders are often also called fragment shaders)</span></span>

    ![Opérations Standard de nuanceur Unity](images/unity-standard-shader-compilation.png)

#### <a name="optmize-pixel-shaders"></a><span data-ttu-id="2a504-256">Optimisation des nuanceurs</span><span class="sxs-lookup"><span data-stu-id="2a504-256">Optmize pixel shaders</span></span>

<span data-ttu-id="2a504-257">Regarder les résultats statistiques compilées à l’aide de la méthode ci-dessus, le [fragment shader](https://en.wikipedia.org/wiki/Shader#Pixel_shaders) exécutera généralement des opérations plus que le [nuanceur de sommets](https://en.wikipedia.org/wiki/Shader#Vertex_shaders) en moyenne.</span><span class="sxs-lookup"><span data-stu-id="2a504-257">Looking at the compiled statistic results using the method above, the [fragment shader](https://en.wikipedia.org/wiki/Shader#Pixel_shaders) will generally execute more operations than the [vertex shader](https://en.wikipedia.org/wiki/Shader#Vertex_shaders) on average.</span></span> <span data-ttu-id="2a504-258">Le nuanceur de fragment, également connu sous le nuanceur de pixels est exécuté par pixel sur l’écran pendant que le nuanceur de sommets est uniquement exécutée par vertex de toutes les mailles dessinés à l’écran de sortie.</span><span class="sxs-lookup"><span data-stu-id="2a504-258">The fragment shader, also known as the pixel shader, is executed per pixel on the screen output while the vertex shader is only executed per-vertex of all meshes being drawn to the screen.</span></span> 

<span data-ttu-id="2a504-259">Par conséquent, non seulement les nuanceurs de fragment ont plus d’instructions que des nuanceurs de sommets en raison de tous les calculs d’éclairage, les nuanceurs de fragment sont presque toujours exécutés dans un dataset plus volumineux.</span><span class="sxs-lookup"><span data-stu-id="2a504-259">Thus, not only do fragment shaders have more instructions than vertex shaders because of all the lighting calculations, fragment shaders are almost always executed on a larger dataset.</span></span> <span data-ttu-id="2a504-260">Par exemple, si la sortie de l’écran est un 2k par 2 image k, le nuanceur de fragment peut obtenir exécutée 2 000 \* 2, = 4,000,000 000 fois.</span><span class="sxs-lookup"><span data-stu-id="2a504-260">For example, if the screen output is a 2k by 2k image, then the fragment shader can get executed 2,000\*2,000 = 4,000,000 times.</span></span> <span data-ttu-id="2a504-261">Si deux yeux de rendu, ce nombre double dans la mesure où il existe deux écrans.</span><span class="sxs-lookup"><span data-stu-id="2a504-261">If rendering two eyes, this number doubles since there are two screens.</span></span> <span data-ttu-id="2a504-262">Si une application de réalité mixte a plusieurs passes, plein écran post-traitement effets ou rendre plusieurs mailles au même pixel, ce nombre augmente considérablement.</span><span class="sxs-lookup"><span data-stu-id="2a504-262">If a mixed reality application has multiple passes, full-screen post-processing effects, or rendering multiple meshes to the same pixel, this number will increase dramatically.</span></span> 

<span data-ttu-id="2a504-263">Par conséquent, ce qui réduit le nombre d’opérations dans le nuanceur de fragment généralement permettent bien plus des gains de performances sur les optimisations dans le nuanceur de sommets.</span><span class="sxs-lookup"><span data-stu-id="2a504-263">Therefore, reducing the number of operations in the fragment shader can generally give far greater performance gains over optimizations in the vertex shader.</span></span>

#### <a name="unity-standard-shader-alternatives"></a><span data-ttu-id="2a504-264">Alternatives de nuanceur Standard Unity</span><span class="sxs-lookup"><span data-stu-id="2a504-264">Unity Standard shader alternatives</span></span>

<span data-ttu-id="2a504-265">Au lieu d’utiliser un rendu physiquement en (PBR) ou autres nuanceur de haute qualité, rechercher l’utilisation d’un plus performant et plus économique nuanceur.</span><span class="sxs-lookup"><span data-stu-id="2a504-265">Instead of using a physically based rendering (PBR) or other high-quality shader, look at utilizing a more performant and cheaper shader.</span></span> <span data-ttu-id="2a504-266">Le [Toolkit de réalité mixte](https://github.com/Microsoft/MixedRealityToolkit-Unity) fournit le [nuanceur standard MRTK](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/README_MRTKStandardShader.html) qui a été optimisé pour les projets de réalité mixte.</span><span class="sxs-lookup"><span data-stu-id="2a504-266">The [Mixed Reality Toolkit](https://github.com/Microsoft/MixedRealityToolkit-Unity) provides the [MRTK standard shader](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/README_MRTKStandardShader.html) that has been optimized for mixed reality projects.</span></span>

<span data-ttu-id="2a504-267">Unity fournit également un éteint, vertex allumée et les options de nuanceur simplifiée diffuse et d’autres qui sont considérablement plus rapide que le nuanceur Unity Standard.</span><span class="sxs-lookup"><span data-stu-id="2a504-267">Unity also provides an unlit, vertex lit, diffuse, and other simplified shader options that are significantly faster compared to the Unity Standard shader.</span></span> <span data-ttu-id="2a504-268">Consultez [l’utilisation et les performances de nuanceurs intégrés](https://docs.unity3d.com/Manual/shader-Performance.html) pour des informations plus détaillées.</span><span class="sxs-lookup"><span data-stu-id="2a504-268">See [Usage and Performance of Built-in Shaders](https://docs.unity3d.com/Manual/shader-Performance.html) for more detailed information.</span></span>

#### <a name="shader-preloading"></a><span data-ttu-id="2a504-269">Le préchargement de nuanceur</span><span class="sxs-lookup"><span data-stu-id="2a504-269">Shader preloading</span></span>

<span data-ttu-id="2a504-270">Utilisez *nuanceur préchargement* et autres astuces pour optimiser [temps de chargement du nuanceur](http://docs.unity3d.com/Manual/OptimizingShaderLoadTime.html).</span><span class="sxs-lookup"><span data-stu-id="2a504-270">Use *Shader preloading* and other tricks to optimize [shader load time](http://docs.unity3d.com/Manual/OptimizingShaderLoadTime.html).</span></span> <span data-ttu-id="2a504-271">En particulier, le préchargement de nuanceur signifie que vous ne voyez pas toutes eu de problèmes en raison de la compilation de nuanceur de runtime.</span><span class="sxs-lookup"><span data-stu-id="2a504-271">In particular, shader preloading means you won't see any hitches due to runtime shader compilation.</span></span>

### <a name="limit-overdraw"></a><span data-ttu-id="2a504-272">Limite de superposition</span><span class="sxs-lookup"><span data-stu-id="2a504-272">Limit overdraw</span></span>

<span data-ttu-id="2a504-273">Dans Unity, un peut afficher superposition pour leur scène, en basculant le [ **dessiner menu mode** ](https://docs.unity3d.com/Manual/ViewModes.html) dans le coin supérieur gauche de la **vue de la scène** et en sélectionnant **superpositions** .</span><span class="sxs-lookup"><span data-stu-id="2a504-273">In Unity, one can display overdraw for their scene, by toggling the [**draw mode menu**](https://docs.unity3d.com/Manual/ViewModes.html) in the top left corner of the **Scene view** and selecting **Overdraw**.</span></span>

<span data-ttu-id="2a504-274">En règle générale, la superposition peut être atténuée à l’élimination des objets à l’avance avant leur envoi vers le GPU.</span><span class="sxs-lookup"><span data-stu-id="2a504-274">Generally, overdraw can be mitigated by culling objects ahead of time before they are sent to the GPU.</span></span> <span data-ttu-id="2a504-275">Unity fournit des détails sur l’implémentation de [coupe d’Occlusion](https://docs.unity3d.com/Manual/OcclusionCulling.html) pour leur moteur.</span><span class="sxs-lookup"><span data-stu-id="2a504-275">Unity provides details on implementing [Occlusion Culling](https://docs.unity3d.com/Manual/OcclusionCulling.html) for their engine.</span></span>

## <a name="memory-recommendations"></a><span data-ttu-id="2a504-276">Recommandations de mémoire</span><span class="sxs-lookup"><span data-stu-id="2a504-276">Memory recommendations</span></span>

<span data-ttu-id="2a504-277">Opérations d’allocation et désallocation de mémoire excessive peuvent avoir des effets négatifs sur votre application holographique avec performances incohérent, cadres figés et autres comportements nuisibles.</span><span class="sxs-lookup"><span data-stu-id="2a504-277">Excessive memory allocation & deallocation operations can have adverse effects on your holographic application resulting in inconsistent performance, frozen frames, and other detrimental behavior.</span></span> <span data-ttu-id="2a504-278">Il est particulièrement important de comprendre les considérations relatives à la mémoire lors du développement dans Unity, étant donné que la gestion de la mémoire est contrôlée par le garbage collector.</span><span class="sxs-lookup"><span data-stu-id="2a504-278">It is especially important to understand memory considerations when developing in Unity since memory management is controlled by the garbage collector.</span></span>

#### <a name="garbage-collection"></a><span data-ttu-id="2a504-279">Le garbage collection</span><span class="sxs-lookup"><span data-stu-id="2a504-279">Garbage collection</span></span>

<span data-ttu-id="2a504-280">Applications HOLOGRAPHIQUE perdent leur temps de calcul de traitement pour le garbage collector (GC) quand le GC est activé pour analyser les objets qui ne sont plus dans la portée lors de l’exécution et leur mémoire doit être libéré peut être rendue disponible pour une réutilisation.</span><span class="sxs-lookup"><span data-stu-id="2a504-280">Holographic apps will loose processing compute time to the garbage collector (GC) when the GC is activated to analyze objects that are no longer in scope during execution and their memory needs to be released so it can be made available for re-use.</span></span> <span data-ttu-id="2a504-281">Allocations de déduplication et constante nécessitera généralement le garbage collector s’exécute plus fréquemment par conséquent promu de performances et l’expérience utilisateur.</span><span class="sxs-lookup"><span data-stu-id="2a504-281">Constant allocations and de-allocations will generally require the garbage collector to run more frequently thus hurting performance and user experience.</span></span>

<span data-ttu-id="2a504-282">Unity a fourni une excellente page qui explique en détail comment le garbage collector fonctionne et conseils pour écrire du code plus efficace en ce qui concerne à la gestion de la mémoire.</span><span class="sxs-lookup"><span data-stu-id="2a504-282">Unity has provided an excellent page that explains in detail how the garbage collector works and tips to write more efficient code in regards to memory management.</span></span>
- [<span data-ttu-id="2a504-283">Optimiser le garbage collection de jeux Unity</span><span class="sxs-lookup"><span data-stu-id="2a504-283">Optimizing garbage collection in Unity games</span></span>](https://unity3d.com/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069)

<span data-ttu-id="2a504-284">Parmi les pratiques les plus courantes qui conduit au garbage collection excessif n'est pas mise en cache des références aux composants et les classes de développement Unity.</span><span class="sxs-lookup"><span data-stu-id="2a504-284">One of the most common practices that leads to excessive garbage collection is not caching references to components and classes in Unity development.</span></span> <span data-ttu-id="2a504-285">Toutes les références doivent être capturées pendant Start() ou Awake() et réutilisés dans les fonctions ultérieures telles que Update() ou LateUpdate().</span><span class="sxs-lookup"><span data-stu-id="2a504-285">Any references should be captured during Start() or Awake() and re-used in later functions such as Update() or LateUpdate().</span></span>

<span data-ttu-id="2a504-286">Autres conseils rapides :</span><span class="sxs-lookup"><span data-stu-id="2a504-286">Other quick tips:</span></span>
- <span data-ttu-id="2a504-287">Utilisez le [StringBuilder](https://docs.microsoft.com/dotnet/api/system.text.stringbuilder?view=netframework-4.7.2) C# classe pour générer dynamiquement des chaînes complexes lors de l’exécution</span><span class="sxs-lookup"><span data-stu-id="2a504-287">Use the [StringBuilder](https://docs.microsoft.com/dotnet/api/system.text.stringbuilder?view=netframework-4.7.2) C# class to dynamically build complex strings at runtime</span></span>
- <span data-ttu-id="2a504-288">Supprimez les appels à Debug.Log() lorsqu’inutile car ils s’exécutent toujours dans toutes les versions de génération d’une application</span><span class="sxs-lookup"><span data-stu-id="2a504-288">Remove calls to Debug.Log() when no longer needed as they still execute in all build versions of an app</span></span>
- <span data-ttu-id="2a504-289">Si votre application HOLOGRAPHIQUE nécessite généralement beaucoup de mémoire, envisagez d’appeler [ _**System.GC.Collect()**_ ](https://docs.microsoft.com/dotnet/api/system.gc.collect?view=netframework-4.7.2) pendant le chargement des phases telles que lors de la présentation d’un chargement ou écran de transition</span><span class="sxs-lookup"><span data-stu-id="2a504-289">If your holographic app generally requires lots of memory, consider calling  [_**System.GC.Collect()**_](https://docs.microsoft.com/dotnet/api/system.gc.collect?view=netframework-4.7.2) during loading phases such as when presenting a loading or transition screen</span></span>

#### <a name="object-pooling"></a><span data-ttu-id="2a504-290">Pool d’objets</span><span class="sxs-lookup"><span data-stu-id="2a504-290">Object pooling</span></span>

<span data-ttu-id="2a504-291">Le pool d’objets est une technique répandue qui permet de réduire le coût des allocations continues & désallocations d’objets.</span><span class="sxs-lookup"><span data-stu-id="2a504-291">Object pooling is a popular technique to reduce the cost of continuous allocations & deallocations of objects.</span></span> <span data-ttu-id="2a504-292">Pour cela, en allouant un grand nombre d’objets identiques et en réutilisant les instances inactives, disponibles à partir de ce pool au lieu de constamment lors de la génération et la destruction d’objets au fil du temps.</span><span class="sxs-lookup"><span data-stu-id="2a504-292">This is done by allocating a large pool of identical objects and re-using inactive, available instances from this pool instead of constantly spawning and destroying objects over time.</span></span> <span data-ttu-id="2a504-293">Les pools d’objet sont idéales pour des composants réutilisables qui possèdent la durée de vie des variable au cours d’une application.</span><span class="sxs-lookup"><span data-stu-id="2a504-293">Object pools are great for re-useable components that have variable lifetime during an app.</span></span>

- [<span data-ttu-id="2a504-294">Objet de regroupement de didacticiel dans Unity</span><span class="sxs-lookup"><span data-stu-id="2a504-294">Object Pooling Tutorial in Unity</span></span>](https://unity3d.com/learn/tutorials/topics/scripting/object-pooling) 

## <a name="startup-performance"></a><span data-ttu-id="2a504-295">Performances de démarrage</span><span class="sxs-lookup"><span data-stu-id="2a504-295">Startup performance</span></span>

<span data-ttu-id="2a504-296">Vous devez envisager de démarrage de votre application avec une scène plus petits, puis à l’aide de *[SceneManager.LoadSceneAsync](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadSceneAsync.html)* pour charger le reste de la scène.</span><span class="sxs-lookup"><span data-stu-id="2a504-296">You should consider starting your app with a smaller scene, then using *[SceneManager.LoadSceneAsync](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadSceneAsync.html)* to load the rest of the scene.</span></span> <span data-ttu-id="2a504-297">Cela permet à votre application accéder à un état interactif aussi rapidement que possible.</span><span class="sxs-lookup"><span data-stu-id="2a504-297">This allows your app to get to an interactive state as fast as possible.</span></span> <span data-ttu-id="2a504-298">Être prenant en charge qui peut contenir un grand pic d’UC pendant que la nouvelle scène est activée et que n’importe quel contenu rendu peut être perturbée ou aucune difficulté.</span><span class="sxs-lookup"><span data-stu-id="2a504-298">Be aware that there may be a large CPU spike while the new scene is being activated and that any rendered content might stutter or hitch.</span></span> <span data-ttu-id="2a504-299">Une façon de contourner ce problème consiste à définir la propriété AsyncOperation.allowSceneActivation sur false sur la scène en cours de chargement, d’attente de la scène charger, désactivez l’écran noir et puis rétabli sur true pour effectuer l’activation de la scène.</span><span class="sxs-lookup"><span data-stu-id="2a504-299">One way to work around this is to set the AsyncOperation.allowSceneActivation property to false on the scene being loaded, wait for the scene to load, clear the screen to black, and then set back to true to complete the scene activation.</span></span>

<span data-ttu-id="2a504-300">N’oubliez pas que, pendant le chargement de la scène de démarrage, l’écran de démarrage holographique est affiché à l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="2a504-300">Remember that while the startup scene is loading the holographic splash screen will be displayed to the user.</span></span>

## <a name="see-also"></a><span data-ttu-id="2a504-301">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="2a504-301">See also</span></span>
- [<span data-ttu-id="2a504-302">Optimisation de rendu de graphiques dans des jeux Unity</span><span class="sxs-lookup"><span data-stu-id="2a504-302">Optimizing graphics rendering in Unity games</span></span>](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games?playlist=44069)
- [<span data-ttu-id="2a504-303">Optimiser le garbage collection de jeux Unity</span><span class="sxs-lookup"><span data-stu-id="2a504-303">Optimizing garbage collection in Unity games</span></span>](https://unity3d.com/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069)
- <span data-ttu-id="2a504-304">[Physique meilleures pratiques [Unity]](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices)</span><span class="sxs-lookup"><span data-stu-id="2a504-304">[Physics Best Practices [Unity]](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices)</span></span>
- <span data-ttu-id="2a504-305">[Optimisation des Scripts [Unity]](https://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html)</span><span class="sxs-lookup"><span data-stu-id="2a504-305">[Optimizing Scripts [Unity]](https://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html)</span></span>
